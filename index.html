<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clean PixiJS Project</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #app {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      canvas {
        display: block;
        width: 100% !important;
        height: 100% !important;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.0.0/dist/pixi.min.js"></script>
    <script type="module">
      import { createEnemyRocket, spawnEnemyRocket } from './src/enemyRocket.js';
      import { createFriendlyRocket } from './src/friendlyRocket.js';
      import { drawCityscapeBackground } from './src/Backdrop/cityscape.js';
      import { drawMoon } from './src/NightSky/moon.js';
      import { drawSimpleStars } from './src/NightSky/starSimple.js';
      import { drawUnifiedStar4 } from './src/NightSky/starUnified4.js';
      import { drawUnifiedStar8 } from './src/NightSky/starUnified8.js';

      // Helper to rotate a point (x, y) around (cx, cy) by angle (radians)
      function rotatePoint(x, y, cx, cy, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return {
          x: (x - cx) * cos - (y - cy) * sin + cx,
          y: (x - cx) * sin + (y - cy) * cos + cy
        };
      }
      // Create the PixiJS application
      const app = new PIXI.Application();
      
      // Initialize the application
      app.init({
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: 0x000000, // Black background
        antialias: true,
      }).then(() => {
        // Add the canvas to the DOM after initialization
        document.getElementById('app').appendChild(app.canvas);

        // Handle window resize
        window.addEventListener('resize', () => {
          app.renderer.resize(window.innerWidth, window.innerHeight);
        });

        // Add to window for debugging
        window.app = app;


        // --- BACKDROP: Center Glow Ball ---


        function drawBackdropCenterGlow() {
          // --- BACKDROP STARS ---
          // --- BACKDROP STARS ---
          drawSimpleStars(app);
          // Disabled external star functions to reduce total special stars to 3-5
          // drawUnifiedStar4(app);
          // drawUnifiedStar8(app);

          // --- MOON OBJECT ---
          function drawMoon() {
            const moonContainer = new PIXI.Container();
            // Position: top right, with some margin
            const margin = Math.min(app.screen.width, app.screen.height) * 0.07;
            const moonRadius = Math.min(app.screen.width, app.screen.height) * 0.035; // even smaller
            const moonX = app.screen.width - margin - moonRadius;
            const moonY = margin + moonRadius;
            // Glow (restored original, stronger)
            const moonGlow = new PIXI.Graphics();
            for (let r = moonRadius * 1.7; r > moonRadius; r -= 1.2) {
              const t = (r - moonRadius) / (moonRadius * 0.7);
              const alpha = 0.18 * Math.pow(1 - t, 2.5);
              if (alpha < 0.01) continue;
              moonGlow.beginFill(0xffffff, alpha);
              moonGlow.drawCircle(0, 0, r);
              moonGlow.endFill();
            }
            moonGlow.x = 0;
            moonGlow.y = 0;
            moonContainer.addChild(moonGlow);
            // Core (main moon disk)
            const moonCore = new PIXI.Graphics();
            moonCore.beginFill(0xffffff, 0.98);
            moonCore.drawCircle(0, 0, moonRadius);
            moonCore.endFill();
            moonCore.x = 0;
            moonCore.y = 0;
            moonContainer.addChild(moonCore);
            // Place moon
            moonContainer.x = moonX;
            moonContainer.y = moonY;
            
            // Make moon interactive for debug menu
            moonContainer.interactive = true;
            moonContainer.buttonMode = true;
            moonContainer.on('pointerdown', toggleDebugMenu);
            
            app.stage.addChildAt(moonContainer, 0);
            window.moon = moonContainer;
          }
          drawMoon();

          // --- DEBUG MENU (HTML) ---
          let debugMenuVisible = false;
          let debugMenuElement = null;

          function toggleDebugMenu() {
            if (debugMenuVisible) {
              hideDebugMenu();
            } else {
              showDebugMenu();
            }
          }

          function showDebugMenu() {
            if (debugMenuElement) {
              debugMenuElement.remove();
            }
            
            // Get moon position
            const moonPos = window.moon;
            const moonScreenX = moonPos.x;
            const moonScreenY = moonPos.y;
            
            // Create debug menu container
            debugMenuElement = document.createElement('div');
            debugMenuElement.id = 'debugMenu';
            debugMenuElement.innerHTML = `
              <div class="debug-title">‚öôÔ∏è DEBUG MENU</div>
              <fieldset class="debug-group">
                <legend class="group-legend">Gameplay</legend>
                <div class="debug-section">
                  <label class="debug-label">Round Duration</label>
                  <div class="slider-container">
                    <input type="range" id="roundDurationSlider" min="10" max="60" step="5" value="${Math.round(roundDuration / 60)}" class="debug-slider">
                    <span class="slider-value">${Math.round(roundDuration / 60)}s</span>
                  </div>
                </div>
                <div class="debug-section">
                  <label class="debug-label">Enemy Rocket Speed</label>
                  <div class="slider-container">
                    <input type="range" id="enemySpeedSlider" min="0.75" max="3.0" step="0.25" value="${enemyRocketSpeed}" class="debug-slider">
                    <span class="slider-value">${enemyRocketSpeed.toFixed(2)}</span>
                  </div>
                </div>
                <div class="debug-section">
                  <label class="debug-label">Friendly Rocket Speed</label>
                  <div class="slider-container">
                    <input type="range" id="friendlySpeedSlider" min="3" max="12" step="1" value="${friendlyRocketSpeed}" class="debug-slider">
                    <span class="slider-value">${friendlyRocketSpeed}</span>
                  </div>
                </div>
              </fieldset>
              <fieldset class="debug-group">
                <legend class="group-legend">Visuals</legend>
                <div class="debug-section">
                  <label class="debug-label">Star Count</label>
                  <div class="slider-container">
                    <input type="range" id="starCountSlider" min="16" max="64" step="4" value="${starCount}" class="debug-slider">
                    <span class="slider-value">${starCount}</span>
                  </div>
                </div>
                <div class="debug-section">
                  <label class="debug-label">Searchlight Width</label>
                  <div class="slider-container">
                    <input type="range" id="searchlightWidthSlider" min="60" max="240" step="20" value="${searchlightWidth}" class="debug-slider">
                    <span class="slider-value">${searchlightWidth}</span>
                  </div>
                </div>
              </fieldset>
              <div class="debug-section">
                <button id="debugStartRound" class="debug-start-btn">üöÄ Start Round</button>
              </div>
              <div class="debug-section">
                <button id="debugStopRound" class="debug-stop-btn">‚èπÔ∏è Stop Round</button>
              </div>
            `;
            
            // Style the debug menu
            debugMenuElement.style.cssText = `
              position: fixed;
              left: ${moonScreenX - 250}px;
              top: ${moonScreenY + 50}px;
              width: 300px;
              padding: 20px 24px;
              background: linear-gradient(135deg, #1a1a2e 0%, #2a2a3e 100%);
              border: 3px solid #00ccff;
              border-radius: 16px;
              box-shadow: 0 8px 32px rgba(0, 204, 255, 0.3), inset 0 2px 4px rgba(255, 255, 255, 0.1);
              color: #ffffff;
              font-family: monospace, 'Courier New', monospace;
              font-weight: bold;
              z-index: 3000;
              backdrop-filter: blur(8px);
              user-select: none;
            `;
            
            document.body.appendChild(debugMenuElement);
            
            // Add styles for debug menu elements
            const style = document.createElement('style');
            style.textContent = `
              .debug-title {
                font-size: 1.2rem;
                color: #00ccff;
                text-align: center;
                margin-bottom: 16px;
                text-shadow: 0 0 8px rgba(0, 204, 255, 0.6);
                letter-spacing: 0.05em;
              }
              
              .debug-section {
                margin-bottom: 12px;
              }
              
              .debug-label {
                display: block;
                font-size: 0.95rem;
                color: #ffffff;
                margin-bottom: 8px;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
              }
              
              .slider-container {
                display: flex;
                align-items: center;
                gap: 12px;
              }
              
              .debug-slider {
                flex: 1;
                height: 8px;
                background: linear-gradient(90deg, #333344, #444455);
                border-radius: 4px;
                outline: none;
                border: 1px solid #00ccff;
                cursor: pointer;
              }
              
              .debug-slider::-webkit-slider-thumb {
                appearance: none;
                width: 20px;
                height: 20px;
                background: linear-gradient(135deg, #00ccff, #ff00cc);
                border-radius: 50%;
                border: 2px solid #ffffff;
                cursor: pointer;
                box-shadow: 0 2px 8px rgba(0, 204, 255, 0.5);
              }
              
              .debug-slider::-moz-range-thumb {
                width: 20px;
                height: 20px;
                background: linear-gradient(135deg, #00ccff, #ff00cc);
                border-radius: 50%;
                border: 2px solid #ffffff;
                cursor: pointer;
                box-shadow: 0 2px 8px rgba(0, 204, 255, 0.5);
              }
              
              .slider-value {
                font-size: 1rem;
                color: #00ff88;
                min-width: 35px;
                text-align: center;
                text-shadow: 0 0 4px rgba(0, 255, 136, 0.6);
                font-weight: bold;
              }
              
              .debug-start-btn {
                width: 100%;
                padding: 12px 20px;
                background: linear-gradient(90deg, #00ccff 0%, #ff00cc 100%);
                color: #ffffff;
                border: 2px solid #ffffff;
                border-radius: 12px;
                font-size: 1.1rem;
                font-weight: bold;
                font-family: monospace;
                cursor: pointer;
                margin-top: 8px;
                box-shadow: 0 4px 16px rgba(0, 204, 255, 0.4);
                transition: all 0.2s ease;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
              }
              
              .debug-start-btn:hover {
                background: linear-gradient(90deg, #ff00cc 0%, #00ccff 100%);
                transform: translateY(-1px);
                box-shadow: 0 6px 20px rgba(0, 204, 255, 0.6);
              }
              
              .debug-start-btn:active {
                transform: translateY(0px);
                box-shadow: 0 2px 8px rgba(0, 204, 255, 0.4);
              }
              
              .debug-stop-btn {
                width: 100%;
                padding: 12px 20px;
                background: linear-gradient(90deg, #ff4444 0%, #cc0000 100%);
                color: #ffffff;
                border: 2px solid #ffffff;
                border-radius: 12px;
                font-size: 1.1rem;
                font-weight: bold;
                font-family: monospace;
                cursor: pointer;
                margin-top: 8px;
                box-shadow: 0 4px 16px rgba(255, 68, 68, 0.4);
                transition: all 0.2s ease;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
              }
              
              .debug-stop-btn:hover {
                background: linear-gradient(90deg, #cc0000 0%, #ff4444 100%);
                transform: translateY(-1px);
                box-shadow: 0 6px 20px rgba(255, 68, 68, 0.6);
              }
              
              .debug-stop-btn:active {
                transform: translateY(0px);
                box-shadow: 0 2px 8px rgba(255, 68, 68, 0.4);
              }
              
              .debug-group {
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 8px;
                padding: 16px 12px 12px 12px;
                margin: 12px 0;
                background: rgba(255, 255, 255, 0.05);
              }
              
              .group-legend {
                color: #00ccff;
                font-weight: bold;
                font-size: 0.9rem;
                padding: 0 8px;
                background: linear-gradient(135deg, #1a1a2e 0%, #2a2a3e 100%);
                border: 1px solid rgba(0, 204, 255, 0.5);
                border-radius: 4px;
                text-shadow: 0 0 4px rgba(0, 204, 255, 0.6);
              }
            `;
            document.head.appendChild(style);
            
            // Add slider and button event listeners
            const slider = document.getElementById('roundDurationSlider');
            const valueDisplay = debugMenuElement.querySelector('.slider-value');
            const startBtn = document.getElementById('debugStartRound');
            const stopBtn = document.getElementById('debugStopRound');
            
            const enemySpeedSlider = document.getElementById('enemySpeedSlider');
            const enemySpeedDisplay = debugMenuElement.querySelectorAll('.slider-value')[1];
            
            const friendlySpeedSlider = document.getElementById('friendlySpeedSlider');
            const friendlySpeedDisplay = debugMenuElement.querySelectorAll('.slider-value')[2];
            
            const starCountSlider = document.getElementById('starCountSlider');
            const starCountDisplay = debugMenuElement.querySelectorAll('.slider-value')[3];
            
            const searchlightWidthSlider = document.getElementById('searchlightWidthSlider');
            const searchlightWidthDisplay = debugMenuElement.querySelectorAll('.slider-value')[4];
            
            slider.addEventListener('input', function(e) {
              const newValue = parseInt(e.target.value);
              roundDuration = newValue * 60; // Convert to frames (60fps)
              valueDisplay.textContent = newValue + 's';
            });
            
            enemySpeedSlider.addEventListener('input', function(e) {
              const newValue = parseFloat(e.target.value);
              enemyRocketSpeed = newValue;
              enemySpeedDisplay.textContent = newValue.toFixed(2);
            });
            
            friendlySpeedSlider.addEventListener('input', function(e) {
              const newValue = parseInt(e.target.value);
              friendlyRocketSpeed = newValue;
              friendlySpeedDisplay.textContent = newValue;
            });
            
            starCountSlider.addEventListener('input', function(e) {
              const newValue = parseInt(e.target.value);
              starCount = newValue;
              starCountDisplay.textContent = newValue;
            });
            
            searchlightWidthSlider.addEventListener('input', function(e) {
              const newValue = parseInt(e.target.value);
              searchlightWidth = newValue;
              searchlightWidthDisplay.textContent = newValue;
            });
            
            startBtn.addEventListener('click', function() {
              // Hide debug menu when starting round
              hideDebugMenu();
              // Call the existing startRound function
              startRound();
            });
            
            stopBtn.addEventListener('click', function() {
              // Hide debug menu when stopping round
              hideDebugMenu();
              // Call the new stopRound function
              stopRound();
            });
            
            debugMenuVisible = true;
          }

          function hideDebugMenu() {
            if (debugMenuElement) {
              debugMenuElement.remove();
              debugMenuElement = null;
            }
            debugMenuVisible = false;
          }

          // --- Unified Star Object (core, glow, spikes, ring) ---
          function makeUnifiedStar(extraDirections = []) {
            const star = new PIXI.Container();
            // Glow (less bright)
            const glow = new PIXI.Graphics();
            const glowRadius = Math.min(app.screen.width, app.screen.height) * 0.027;
            const coreRadius = Math.max(0.5, glowRadius * 0.09);
            for (let r = glowRadius; r > 0; r -= 0.5) {
              const t = r / glowRadius;
              const alpha = 0.13 * Math.pow(1 - t, 2.5); // was 0.28
              if (alpha < 0.003) continue;
              glow.beginFill(0xffffff, alpha);
              glow.drawCircle(0, 0, r);
              glow.endFill();
            }
            glow.x = 0;
            glow.y = 0;
            star.addChild(glow);
            // Core (less bright)
            const core = new PIXI.Graphics();
            core.beginFill(0xffffff, 0.32); // was 0.68
            core.drawCircle(0, 0, coreRadius);
            core.endFill();
            core.x = 0;
            core.y = 0;
            star.addChild(core);          // Spikes (less bright)
          const spikeLength = glowRadius * 2.45 * 2 * 0.75;
          const baseSpikeLengthH = spikeLength * 1.04; // halved from 2.08
          // Randomize horizontal spike length between 1x and 4x the default length
          const spikeLengthH = baseSpikeLengthH * (1 + Math.random() * 3);
          const spikeLengthV = spikeLength * 0.54;
            const spikeWidth = Math.max(1.2, glowRadius * 0.13);
            const fadeStepsH = 18;
            const fadeStepsV = 38;
            // 4 main directions
            const directions = [
              [-1, 0],
              [1, 0],
              [0, -1],
              [0, 1],
            ];
            // Add extra directions if provided (for 8-spiked star)
            const allDirections = directions.concat(extraDirections);
            for (const [dx, dy] of allDirections) {
              const perp = [-dy, dx];
              // For diagonal spikes, treat as vertical for fade/length
              const isHorizontal = dx !== 0 && dy === 0;
              const isDiagonal = Math.abs(dx) === 1 && Math.abs(dy) === 1;
              const fadeSteps = isHorizontal ? fadeStepsH : fadeStepsV;
              for (let i = 0; i < fadeSteps; i++) {
                const t = i / fadeSteps;
                const alpha = isHorizontal
                  ? 0.06 * (1 - t) * (1 - t) // was 0.13
                  : 0.06 * Math.pow(1 - t, 2.7); // was 0.13
                if (alpha < 0.005) continue;
                const g = new PIXI.Graphics();
                g.beginFill(0xffffff, alpha);
                // For diagonal, start at center ball, same as vertical
                let startLen = coreRadius;
                if (!isHorizontal) {
                  startLen = coreRadius * 0.85;
                }
                // For diagonal, use vertical length
                let len = startLen + t * ((isHorizontal ? spikeLengthH : spikeLengthV) - startLen);
                let w = spikeWidth * (1 - t * 0.7);
                // For diagonal, compensate for aspect ratio in both x and y
                let x0 = dx * startLen + perp[0] * (-w / 2);
                let y0 = dy * startLen + perp[1] * (-w / 2);
                let x1 = dx * startLen + perp[0] * (w / 2);
                let y1 = dy * startLen + perp[1] * (w / 2);
                let x2 = dx * len + perp[0] * (w / 2);
                let y2 = dy * len + perp[1] * (w / 2);
                let x3 = dx * len + perp[0] * (-w / 2);
                let y3 = dy * len + perp[1] * (-w / 2);
                if (isHorizontal) {
                  // Reduce aspect ratio scaling to make horizontal spikes shorter
                  const aspectScale = 0.3; // much smaller than original (app.screen.height / app.screen.width)
                  x0 *= aspectScale;
                  x1 *= aspectScale;
                  x2 *= aspectScale;
                  x3 *= aspectScale;
                }
                if ((dy !== 0 && dx === 0) || isDiagonal) {
                  y0 *= app.screen.width / app.screen.height;
                  y1 *= app.screen.width / app.screen.height;
                  y2 *= app.screen.width / app.screen.height;
                  y3 *= app.screen.width / app.screen.height;
                }
                g.moveTo(x0, y0);
                g.lineTo(x1, y1);
                g.lineTo(x2, y2);
                g.lineTo(x3, y3);
                g.closePath();
                g.endFill();
                g.x = 0;
                g.y = 0;
                star.addChild(g);
              }
            }
            // Ring (less bright)
            const ring = new PIXI.Graphics();
            const ringInner = coreRadius * 0.33;
            const ringOuter = coreRadius * 0.33 + Math.max(1.0, glowRadius * 0.07);
            for (let r = ringOuter; r > ringInner; r -= 0.3) {
              const t = (r - ringInner) / (ringOuter - ringInner);
              const alpha = 0.13 * (1 - t) + 0.03 * t; // was 0.38/0.07
              ring.beginFill(0xffffff, alpha);
              ring.drawCircle(0, 0, r);
              ring.endFill();
            }
            ring.x = 0;
            ring.y = 0;
            star.addChild(ring);
            // Set pivot to center for rotation
            star.pivot.set(0, 0);
            return star;
          }

          // --- Place 4-5 randomly scattered 4- or 8-spiked stars in the sky ---
          const diag = Math.SQRT1_2; // 1/sqrt(2)
          const diagonalDirections = [
            [diag, diag],
            [-diag, diag],
            [diag, -diag],
            [-diag, -diag],
          ];
          const numStars = 3 + Math.floor(Math.random() * 3); // 3, 4, or 5
          const starObjs = [];
          // Use same highest building Y as above
          const bgMaxHeight = 220;
          const bgBaseY = app.screen.height - 120;
          const highestBuildingY = bgBaseY - bgMaxHeight;
          for (let i = 0; i < numStars; i++) {
            // Randomly choose 4- or 8-spiked
            const isEight = Math.random() < 0.5;
            const star = isEight ? makeUnifiedStar(diagonalDirections) : makeUnifiedStar();
            // Random position in sky, always above highest building
            star.x = Math.random() * app.screen.width;
            const minY = 0;
            const maxY = highestBuildingY - 16;
            star.y = minY + Math.random() * (maxY - minY);
            // Random rotation
            star.rotation = Math.random() * Math.PI * 2;
            app.stage.addChildAt(star, 0);
            starObjs.push(star);
          }
          window.skyStars = starObjs;
        }
        drawBackdropCenterGlow();

        // --- CITYSCAPE BACKGROUND (faint, composited buildings) ---
        drawCityscapeBackground(app);

        // --- MULTIPLE BUILDINGS AND BUNKER SETUP ---
        const buildingPieces = [];
        const explosionParticles = [];
        // Track active growing player explosions
        const activePlayerExplosions = [];
        const rockets = [];

        // Building and bunker dimensions
        const buildingWidth = 50;
        const buildingHeight = 75;
        const pieceWidth = buildingWidth / 4;
        const pieceHeight = buildingHeight / 4;
        const bunkerWidth = buildingWidth * 2;
        const bunkerHeight = 38;
        const bottomY = app.screen.height;
        const centerX = app.screen.width / 2;

        // Calculate building positions
        const numBuildingsPerSide = 3;
        const totalBuildings = 6;
        const leftSpace = centerX - bunkerWidth / 2;
        const rightSpace = app.screen.width - (centerX + bunkerWidth / 2);
        const leftSpacing = leftSpace / (numBuildingsPerSide + 1);
        const rightSpacing = rightSpace / (numBuildingsPerSide + 1);

        // Store all building centers
        const buildingCenters = [];
        // Left side buildings
        for (let i = 1; i <= numBuildingsPerSide; i++) {
          buildingCenters.push(leftSpacing * i - buildingWidth / 2);
        }
        // Right side buildings
        for (let i = 1; i <= numBuildingsPerSide; i++) {
          buildingCenters.push(centerX + bunkerWidth / 2 + rightSpacing * i - buildingWidth / 2);
        }

        // --- Track destroyed state for each building ---
        // destroyedBuildings[i] = true if building i is destroyed
        let destroyedBuildings = [];

        // Draw all buildings (each as 16 pieces, roof, antennas)
        function drawBuilding(centerX, bottomY) {
          const pieces = [];
          const pieceWidth = buildingWidth / 4;
          const pieceHeight = buildingHeight / 4;
          // Roof
          const roofHeight = 12;
          const roofWidth = buildingWidth + 10;
          const roofX = centerX - roofWidth / 2;
          const roofY = bottomY - buildingHeight - roofHeight + 2;
          // Left roof part
          const roofLeft = new PIXI.Graphics();
          roofLeft.beginFill(0x222244);
          roofLeft.lineStyle(2, 0x00ffff, 0.7);
          roofLeft.moveTo(0, roofHeight);
          roofLeft.lineTo(roofWidth * 0.18, 0);
          roofLeft.lineTo(roofWidth * 0.5, 0);
          roofLeft.lineTo(roofWidth * 0.5, roofHeight);
          roofLeft.lineTo(0, roofHeight);
          roofLeft.endFill();
          roofLeft.x = roofX;
          roofLeft.y = roofY;
          roofLeft.gridX = -1;
          roofLeft.gridY = -1;
          roofLeft.originalX = roofX + roofWidth * 0.25;
          roofLeft.originalY = roofY + roofHeight / 2;
          pieces.push(roofLeft);
          app.stage.addChild(roofLeft);
          // Right roof part
          const roofRight = new PIXI.Graphics();
          roofRight.beginFill(0x222244);
          roofRight.lineStyle(2, 0x00ffff, 0.7);
          roofRight.moveTo(roofWidth * 0.5, roofHeight);
          roofRight.lineTo(roofWidth * 0.5, 0);
          roofRight.lineTo(roofWidth * 0.82, 0);
          roofRight.lineTo(roofWidth, roofHeight);
          roofRight.lineTo(roofWidth * 0.5, roofHeight);
          roofRight.endFill();
          roofRight.x = roofX;
          roofRight.y = roofY;
          roofRight.gridX = -2;
          roofRight.gridY = -2;
          roofRight.originalX = roofX + roofWidth * 0.75;
          roofRight.originalY = roofY + roofHeight / 2;
          pieces.push(roofRight);
          app.stage.addChild(roofRight);
          // 16 grid pieces
          for (let row = 0; row < 4; row++) {
            for (let col = 0; col < 4; col++) {
              const piece = new PIXI.Graphics();
              const pieceX = centerX - buildingWidth / 2 + col * pieceWidth;
              const pieceY = bottomY - buildingHeight + row * pieceHeight;
              piece.x = pieceX;
              piece.y = pieceY;
              piece.beginFill(0x2a2a3e); // Slightly lighter building color
              piece.drawRect(0, 0, pieceWidth, pieceHeight);
              piece.endFill();
              piece.lineStyle(1, 0x00ffff);
              // Draw exterior borders
              if (col === 0) { piece.moveTo(0, 0); piece.lineTo(0, pieceHeight); }
              if (col === 3) { piece.moveTo(pieceWidth, 0); piece.lineTo(pieceWidth, pieceHeight); }
              if (row === 0) { piece.moveTo(0, 0); piece.lineTo(pieceWidth, 0); }
              if (row === 3) { piece.moveTo(0, pieceHeight); piece.lineTo(pieceWidth, pieceHeight); }
              // Draw horizontal lines between rows, but skip window areas
              if (row === 1 || row === 2) { 
                // Only draw horizontal lines outside window columns (1 and 2)
                if (col === 0 || col === 3) {
                  piece.moveTo(0, pieceHeight); piece.lineTo(pieceWidth, pieceHeight); 
                }
              }
              // Skip vertical lines in window columns (1 and 2) to avoid interfering with windows
              piece.lineStyle(0);
              if ((row === 0 && (col === 1 || col === 2)) ||
                (row === 1 && (col === 1 || col === 2)) ||
                (row === 2 && (col === 1 || col === 2))) {
                // 80% chance lights are on, 20% chance lights are off
                const lightIsOn = Math.random() < 0.8;
                const windowMargin = 2;
                
                if (lightIsOn) {
                  // Light is on - draw yellow window
                  piece.beginFill(0xfff4cc);
                  piece.drawRect(windowMargin, windowMargin, pieceWidth - windowMargin * 2, pieceHeight - windowMargin * 2);
                  piece.endFill();
                } else {
                  // Light is off - draw dark window (darker than building)
                  piece.beginFill(0x0a0a15); // Much darker than building background (0x1a1a2e)
                  piece.drawRect(windowMargin, windowMargin, pieceWidth - windowMargin * 2, pieceHeight - windowMargin * 2);
                  piece.endFill();
                }
              }
              if (col === 0 && (row === 1 || row === 2)) {
                piece.beginFill(0x00ff88);
                piece.drawRect(-3, 0, 3, pieceHeight);
                piece.endFill();
              }
              if (col === 3 && (row === 1 || row === 2)) {
                piece.beginFill(0x00ff88);
                piece.drawRect(pieceWidth, 0, 3, pieceHeight);
                piece.endFill();
              }
              piece.gridX = col;
              piece.gridY = row;
              piece.originalX = pieceX + pieceWidth / 2;
              piece.originalY = pieceY + pieceHeight / 2;
              pieces.push(piece);
              app.stage.addChild(piece);
            }
          }
          // Antennas
          function createAntenna(x, y, height, color, tipColor) {
            const antenna = new PIXI.Graphics();
            antenna.lineStyle(3, color, 0.8);
            antenna.moveTo(0, 0);
            antenna.lineTo(0, -height);
            antenna.beginFill(tipColor);
            antenna.drawCircle(0, -height, 4);
            antenna.endFill();
            antenna.x = x;
            antenna.y = y;
            antenna.alpha = 0.85;
            antenna.originalX = x;
            antenna.originalY = y - height / 2;
            antenna.isAntenna = true;
            pieces.push(antenna);
            app.stage.addChild(antenna);
          }
          createAntenna(roofX + 8, roofY + 2, 28, 0x00ffff, 0x00ffff);
          createAntenna(roofX + roofWidth - 8, roofY + 2, 28, 0xff00ff, 0xff00ff);
          // Add all to global buildingPieces
          buildingPieces.push(...pieces);
        }

        // Draw all 6 buildings
        for (let i = 0; i < buildingCenters.length; i++) {
          drawBuilding(buildingCenters[i] + buildingWidth / 2, bottomY);
        }

        // Draw a satellite dish on the left pole of the bunker
        function drawDishOnLeftPole() {
          const dish = new PIXI.Graphics();
          // Dish geometry
          const radius = 24;
          const startAngle = Math.PI * 1.2;
          const endAngle = Math.PI * 1.8;
          dish.lineStyle(3, 0xcccccc, 1.0);
          dish.beginFill(0xdddddd, 0.85);
          dish.arc(0, 0, radius, startAngle, endAngle, false);
          // Draw the straight (hollow) side
          const sx = Math.cos(startAngle) * radius;
          const sy = Math.sin(startAngle) * radius;
          const ex = Math.cos(endAngle) * radius;
          const ey = Math.sin(endAngle) * radius;
          dish.lineTo(ex, ey);
          dish.lineStyle(0);
          dish.endFill();

          // Calculate flat side angle and rod length
          const flatAngle = Math.atan2(ey - sy, ex - sx);
          const rodLength = 20;
          const mx = (sx + ex) / 2;
          const my = (sy + ey) / 2;
          const rodWidth = 3;
          const rodAngle = flatAngle + Math.PI / 2;
          const rodStartX = mx;
          const rodStartY = my;
          const rodEndX = mx + Math.cos(rodAngle) * rodLength;
          const rodEndY = my + Math.sin(rodAngle) * rodLength;
          const perpX = Math.cos(rodAngle + Math.PI / 2) * (rodWidth / 2);
          const perpY = Math.sin(rodAngle + Math.PI / 2) * (rodWidth / 2);
          const p1x = rodStartX + perpX;
          const p1y = rodStartY + perpY;
          const p2x = rodStartX - perpX;
          const p2y = rodStartY - perpY;
          const p3x = rodEndX - perpX;
          const p3y = rodEndY - perpY;
          const p4x = rodEndX + perpX;
          const p4y = rodEndY + perpY;
          dish.beginFill(0xbbbbbb);
          dish.moveTo(p1x, p1y);
          dish.lineTo(p2x, p2y);
          dish.lineTo(p3x, p3y);
          dish.lineTo(p4x, p4y);
          dish.closePath();
          dish.endFill();

          // Red dot receiver with pulsating glow
          const receiverGlow = new PIXI.Graphics();
          const receiverDot = new PIXI.Graphics();
          const receiverRadius = 4;
          const glowBaseRadius = 9;
          const glowColor = 0xff2222;
          const dotColor = 0xff0000;
          receiverGlow.x = rodEndX;
          receiverGlow.y = rodEndY;
          receiverDot.x = rodEndX;
          receiverDot.y = rodEndY;
          receiverGlow.beginFill(glowColor, 0.4);
          receiverGlow.drawCircle(0, 0, glowBaseRadius);
          receiverGlow.endFill();
          receiverDot.beginFill(dotColor, 1.0);
          receiverDot.drawCircle(0, 0, receiverRadius);
          receiverDot.endFill();
          dish.addChild(receiverGlow);
          dish.addChild(receiverDot);

          let glowTicker = 0;
          app.ticker.add(() => {
            glowTicker += 0.04;
            const pulse = 0.5 + 0.5 * Math.sin(glowTicker);
            const glowAlpha = 0.3 + 0.4 * pulse;
            const glowRadius = glowBaseRadius + 5.5 * pulse;
            receiverGlow.clear();
            receiverGlow.beginFill(glowColor, glowAlpha);
            receiverGlow.drawCircle(0, 0, glowRadius);
            receiverGlow.endFill();
          });

          // --- Placement and rotation ---
          // Left pole top coordinates (same as bunker pole)
          const poleWidth = 4;
          const poleHeight = 38;
          const poleLeftX = centerX - bunkerWidth / 2 - 6 + poleWidth / 2;
          const poleLeftY = bottomY - bunkerHeight - 10 - poleHeight;


          // We want the flat side (with the rod) to point 45 degrees to the top left.
          // The flat side is from (sx,sy) to (ex,ey), midpoint (mx,my), and its outward normal is rodAngle.
          // So, set dish.rotation so that rodAngle (in local dish space) aligns with -45 degrees (top left).
          // rodAngle in local dish space is flatAngle + Math.PI/2, so:
          // dish.rotation = -Math.PI/4 - rodAngle = -Math.PI/4 - (flatAngle + Math.PI/2)
          // But Pixi rotates the whole dish, so to make the rod point -45deg, set:
          // To point the rod 45 degrees to the top left, use +Math.PI/4 (135deg, counterclockwise from x axis)
          const desiredRodAngle = -3 * Math.PI / 4; // 135deg (top left)
          const dishRotation = desiredRodAngle - rodAngle;
          dish.rotation = dishRotation;

          // Now, after rotation, the round side midpoint must connect to the top of the pole.
          // Compute the rotated position of the round side midpoint
          const roundMidAngle = (startAngle + endAngle) / 2;
          const roundMidX = Math.cos(roundMidAngle) * radius;
          const roundMidY = Math.sin(roundMidAngle) * radius;
          // Rotate this point by dishRotation
          const cosR = Math.cos(dishRotation);
          const sinR = Math.sin(dishRotation);
          const roundMidXr = roundMidX * cosR - roundMidY * sinR;
          const roundMidYr = roundMidX * sinR + roundMidY * cosR;
          // Place dish so that (dish.x + roundMidXr, dish.y + roundMidYr) = (poleLeftX, poleLeftY)
          dish.x = poleLeftX - roundMidXr;
          dish.y = poleLeftY - roundMidYr;

          app.stage.addChild(dish);
        }
        drawDishOnLeftPole();

        // Draw a satellite dish on the right pole of the bunker, mirrored
        function drawDishOnRightPole() {
          const dish = new PIXI.Graphics();
          // Use the same geometry as the left dish
          const radius = 24;
          const startAngle = Math.PI * 1.2;
          const endAngle = Math.PI * 1.8;
          dish.lineStyle(3, 0xcccccc, 1.0);
          dish.beginFill(0xdddddd, 0.85);
          dish.arc(0, 0, radius, startAngle, endAngle, false);
          // Draw the straight (hollow) side
          const sx = Math.cos(startAngle) * radius;
          const sy = Math.sin(startAngle) * radius;
          const ex = Math.cos(endAngle) * radius;
          const ey = Math.sin(endAngle) * radius;
          dish.lineTo(ex, ey);
          dish.lineStyle(0);
          dish.endFill();

          // Calculate flat side angle and rod length
          const flatAngle = Math.atan2(ey - sy, ex - sx);
          const rodLength = 20;
          const mx = (sx + ex) / 2;
          const my = (sy + ey) / 2;
          const rodWidth = 3;
          const rodAngle = flatAngle + Math.PI / 2;
          const rodStartX = mx;
          const rodStartY = my;
          const rodEndX = mx + Math.cos(rodAngle) * rodLength;
          const rodEndY = my + Math.sin(rodAngle) * rodLength;
          const perpX = Math.cos(rodAngle + Math.PI / 2) * (rodWidth / 2);
          const perpY = Math.sin(rodAngle + Math.PI / 2) * (rodWidth / 2);
          const p1x = rodStartX + perpX;
          const p1y = rodStartY + perpY;
          const p2x = rodStartX - perpX;
          const p2y = rodStartY - perpY;
          const p3x = rodEndX - perpX;
          const p3y = rodEndY - perpY;
          const p4x = rodEndX + perpX;
          const p4y = rodEndY + perpY;
          dish.beginFill(0xbbbbbb);
          dish.moveTo(p1x, p1y);
          dish.lineTo(p2x, p2y);
          dish.lineTo(p3x, p3y);
          dish.lineTo(p4x, p4y);
          dish.closePath();
          dish.endFill();

          // Red dot receiver with pulsating glow
          const receiverGlow = new PIXI.Graphics();
          const receiverDot = new PIXI.Graphics();
          const receiverRadius = 4;
          const glowBaseRadius = 9;
          const glowColor = 0xff2222;
          const dotColor = 0xff0000;
          receiverGlow.x = rodEndX;
          receiverGlow.y = rodEndY;
          receiverDot.x = rodEndX;
          receiverDot.y = rodEndY;
          receiverGlow.beginFill(glowColor, 0.4);
          receiverGlow.drawCircle(0, 0, glowBaseRadius);
          receiverGlow.endFill();
          receiverDot.beginFill(dotColor, 1.0);
          receiverDot.drawCircle(0, 0, receiverRadius);
          receiverDot.endFill();
          dish.addChild(receiverGlow);
          dish.addChild(receiverDot);

          let glowTicker = 0;
          app.ticker.add(() => {
            glowTicker += 0.04;
            const pulse = 0.5 + 0.5 * Math.sin(glowTicker);
            const glowAlpha = 0.3 + 0.4 * pulse;
            const glowRadius = glowBaseRadius + 5.5 * pulse;
            receiverGlow.clear();
            receiverGlow.beginFill(glowColor, glowAlpha);
            receiverGlow.drawCircle(0, 0, glowRadius);
            receiverGlow.endFill();
          });

          // --- Placement and rotation ---
          // Right pole top coordinates (same as bunker pole)
          const poleWidth = 4;
          const poleHeight = 38;
          const poleRightX = centerX + bunkerWidth / 2 + 6 - poleWidth / 2;
          const poleRightY = bottomY - bunkerHeight - 10 - poleHeight;

          // We want the flat side (with the rod) to point 45 degrees to the top right.
          // So, set dish.rotation so that rodAngle aligns with +45deg (top right)
          const desiredRodAngle = -Math.PI / 4; // -45deg (top right)
          const dishRotation = desiredRodAngle - rodAngle;
          dish.rotation = dishRotation;

          // Now, after rotation, the round side midpoint must connect to the top of the pole.
          const roundMidAngle = (startAngle + endAngle) / 2;
          const roundMidX = Math.cos(roundMidAngle) * radius;
          const roundMidY = Math.sin(roundMidAngle) * radius;
          const cosR = Math.cos(dishRotation);
          const sinR = Math.sin(dishRotation);
          const roundMidXr = roundMidX * cosR - roundMidY * sinR;
          const roundMidYr = roundMidX * sinR + roundMidY * cosR;
          dish.x = poleRightX - roundMidXr;
          dish.y = poleRightY - roundMidYr;

          app.stage.addChild(dish);
        }
        drawDishOnRightPole();

        // --- FRIENDLY ROCKET ICONS (visual indicator, step 1) ---
        // Container for rocket icons
        const rocketIconsContainer = new PIXI.Container();
        app.stage.addChild(rocketIconsContainer);

        // --- FRIENDLY ROCKET LIMIT LOGIC (step 2) ---
        const MAX_FRIENDLY_ROCKETS = 3;
        let availableFriendlyRockets = MAX_FRIENDLY_ROCKETS;
        // Each element: true = green (available), false = red (used)
        let rocketIconsState = [true, true, true];

        // Draw/update the 3 rocket icons (triangles)
        function drawRocketIcons(iconsState = rocketIconsState) {
          rocketIconsContainer.removeChildren();
          const iconCount = 3;
          const iconSpacing = 20; // closer together
          const iconWidth = 12;   // smaller width
          const iconHeight = 18;  // smaller height
          const y = bottomY - bunkerHeight - 44; // move up by 10px
          const totalWidth = (iconCount - 1) * iconSpacing;
          const startX = centerX - totalWidth / 2;
          for (let i = 0; i < iconCount; i++) {
            const icon = new PIXI.Graphics();
            const color = iconsState[i] ? 0x00ff44 : 0xff2222;
            // Draw missile body (rectangle)
            const bodyWidth = 5;
            const bodyHeight = 12;
            // If unavailable (red), body is red; if available, body is gray
            const bodyColor = iconsState[i] ? 0xcccccc : 0xff2222;
            icon.beginFill(bodyColor);
            icon.drawRect((iconWidth - bodyWidth) / 2, -bodyHeight, bodyWidth, bodyHeight);
            icon.endFill();

            // Draw nose cone (triangle)
            icon.beginFill(color); // green or red nose
            icon.moveTo(iconWidth / 2, -iconHeight); // tip
            icon.lineTo((iconWidth / 2) - 4, -bodyHeight);
            icon.lineTo((iconWidth / 2) + 4, -bodyHeight);
            icon.lineTo(iconWidth / 2, -iconHeight);
            icon.endFill();

            // Draw fins (two small triangles)
            icon.beginFill(0x888888); // darker gray for fins
            // Left fin
            icon.moveTo((iconWidth / 2) - 2, 0);
            icon.lineTo((iconWidth / 2) - 7, 4);
            icon.lineTo((iconWidth / 2) - 2, -2);
            icon.lineTo((iconWidth / 2) - 2, 0);
            // Right fin
            icon.moveTo((iconWidth / 2) + 2, 0);
            icon.lineTo((iconWidth / 2) + 7, 4);
            icon.lineTo((iconWidth / 2) + 2, -2);
            icon.lineTo((iconWidth / 2) + 2, 0);
            icon.endFill();

            // Optional: Draw a small exhaust circle at the base
            icon.beginFill(0xffcc00, 0.7); // yellow-orange exhaust
            icon.drawCircle(iconWidth / 2, 2, 1.5);
            icon.endFill();

            icon.x = startX + i * iconSpacing - iconWidth / 2;
            icon.y = y;
            rocketIconsContainer.addChild(icon);
          }
        }
        // Draw initial icons (all green)
        drawRocketIcons();

        // Per-rocket cooldown timers: when a rocket is fired, start a 2s timer to restore it
        let rocketCooldownTimers = [null, null, null];

        function startRocketCooldown(index) {
          if (rocketCooldownTimers[index]) return; // Already running
          rocketCooldownTimers[index] = setTimeout(() => {
            // Restore this rocket slot only
            if (!rocketIconsState[index]) {
              rocketIconsState[index] = true;
              availableFriendlyRockets++;
              drawRocketIcons();
            }
            clearTimeout(rocketCooldownTimers[index]);
            rocketCooldownTimers[index] = null;
          }, 2000);
        }

        // Draw the central bunker as a military structure
        function drawBunker(centerX, bottomY) {
          // (Searchlight beam logic moved to animation loop)
          // --- TOP TRAPEZOID STRUCTURE ---
          // Smaller trapezoid dimensions
          const trapezoidWidth = bunkerWidth * 0.45;
          const trapezoidHeight = 22;
          const trapezoidSlope = 18; // match bunker base slope
          // Place directly on top of the bunker roof
          const roofTopY = bottomY - bunkerHeight - 10; // roof top (roof is 14px tall)
          const trapezoidBaseY = roofTopY;
          const trapezoidTopY = roofTopY - trapezoidHeight;
          const trapezoidLeftX = centerX - trapezoidWidth / 2;
          const trapezoidRightX = centerX + trapezoidWidth / 2;
          // Outer border
          const topTrapezoid = new PIXI.Graphics();
          topTrapezoid.lineStyle(6, 0x888c99, 1.0);
          topTrapezoid.beginFill(0x33363a); // dark gray inner color
          topTrapezoid.moveTo(trapezoidLeftX - trapezoidSlope, trapezoidBaseY);
          topTrapezoid.lineTo(trapezoidRightX + trapezoidSlope, trapezoidBaseY);
          topTrapezoid.lineTo(trapezoidRightX, trapezoidTopY);
          topTrapezoid.lineTo(trapezoidLeftX, trapezoidTopY);
          topTrapezoid.lineTo(trapezoidLeftX - trapezoidSlope, trapezoidBaseY);
          topTrapezoid.endFill();
          app.stage.addChild(topTrapezoid);

          const bunker = new PIXI.Graphics();
          // Main body: thick, angular, concrete look
          bunker.beginFill(0x33363a);
          bunker.lineStyle(6, 0x888c99, 1.0);
          // Trapezoidal base for sloped armor
          const baseY = bottomY;
          const topY = bottomY - bunkerHeight;
          const slope = 18;
          bunker.moveTo(centerX - bunkerWidth / 2 - slope, baseY);
          bunker.lineTo(centerX + bunkerWidth / 2 + slope, baseY);
          bunker.lineTo(centerX + bunkerWidth / 2, topY);
          bunker.lineTo(centerX - bunkerWidth / 2, topY);
          bunker.lineTo(centerX - bunkerWidth / 2 - slope, baseY);
          bunker.endFill();

          // Flat reinforced roof
          bunker.beginFill(0x44474c);
          bunker.lineStyle(0);
          bunker.drawRect(centerX - bunkerWidth / 2 - 6, topY - 10, bunkerWidth + 12, 14);
          bunker.endFill();

          // Firing slits (narrow, dark, evenly spaced)
          const slitCount = 5;
          const slitWidth = bunkerWidth * 0.10;
          const slitHeight = 7;
          const slitY = topY + 18;
          for (let i = 0; i < slitCount; i++) {
            const slitX = centerX - bunkerWidth / 2 + (bunkerWidth / (slitCount + 1)) * (i + 1) - slitWidth / 2;
            // Glowing blue window
            bunker.beginFill(0x00ccff);
            bunker.lineStyle(2, 0x00ffff, 0.7);
            bunker.drawRoundedRect(slitX, slitY, slitWidth, slitHeight, 3);
            bunker.endFill();
            bunker.lineStyle(0);
          }

          // Reinforcement lines (horizontal)
          bunker.lineStyle(2, 0x888c99, 0.5);
          for (let i = 1; i <= 2; i++) {
            const y = baseY - (bunkerHeight * i) / 3;
            bunker.moveTo(centerX - bunkerWidth / 2 - slope / 2, y);
            bunker.lineTo(centerX + bunkerWidth / 2 + slope / 2, y);
          }

          // Add a thick base border for extra strength
          bunker.lineStyle(8, 0x888c99, 0.8);
          bunker.moveTo(centerX - bunkerWidth / 2 - slope, baseY);
          bunker.lineTo(centerX + bunkerWidth / 2 + slope, baseY);

          app.stage.addChild(bunker);

          // --- SATELLITE DISH POLES ---
          // Left pole
          const poleLeft = new PIXI.Graphics();
          const poleWidth = 4;
          const poleHeight = 38;
          const poleColor = 0x44474c; // same as bunker roof
          // Place at left edge of roof
          const poleLeftX = centerX - bunkerWidth / 2 - 6 + poleWidth / 2;
          const poleLeftY = topY - 10;
          poleLeft.beginFill(poleColor);
          poleLeft.drawRect(-poleWidth / 2, -poleHeight, poleWidth, poleHeight);
          poleLeft.endFill();
          poleLeft.x = poleLeftX;
          poleLeft.y = poleLeftY;
          app.stage.addChild(poleLeft);

          // Right pole
          const poleRight = new PIXI.Graphics();
          const poleRightX = centerX + bunkerWidth / 2 + 6 - poleWidth / 2;
          const poleRightY = topY - 10;
          poleRight.beginFill(poleColor);
          poleRight.drawRect(-poleWidth / 2, -poleHeight, poleWidth, poleHeight);
          poleRight.endFill();
          poleRight.x = poleRightX;
          poleRight.y = poleRightY;
          app.stage.addChild(poleRight);
        }
        drawBunker(centerX, bottomY);

        // --- SEARCHLIGHT BEAM: Draw and animate in main loop ---
        // Create a container for the searchlight so we can update it each frame
        const searchlightContainer = new PIXI.Container();
        app.stage.addChildAt(searchlightContainer, 0); // behind bunker

        // Store state for animation (angle, etc.) and visibility
        window._searchlightState = {
          angle: 0, // straight up
          visible: true, // searchlight is on by default
          direction: 1, // 1 for right, -1 for left
          speed: 0.0025 // radians per frame (half the original speed)
        };

        function drawSearchlight() {
          // Remove previous beam
          searchlightContainer.removeChildren();
          // Only draw if visible
          if (!window._searchlightState.visible) return;
          // Parameters for searchlight
          const beamBaseY = bottomY - bunkerHeight - 10; // roof top
          const beamBaseX = centerX;
          const beamBaseWidth = 4;
          const beamTopWidth = searchlightWidth;
          const beamAlpha = 0.13;
          // Animate angle (in radians)
          const angle = window._searchlightState.angle || 0;
          // Extend the beam much further into the sky (2.5x the screen height)
          const farSkyY = beamBaseY - app.screen.height * 2.5;
          // Base points (at bunker roof)
          const baseLeft = rotatePoint(
            beamBaseX - beamBaseWidth / 2,
            beamBaseY,
            beamBaseX,
            beamBaseY,
            angle
          );
          const baseRight = rotatePoint(
            beamBaseX + beamBaseWidth / 2,
            beamBaseY,
            beamBaseX,
            beamBaseY,
            angle
          );
          // Top points (far into the sky)
          const topLeft = rotatePoint(
            beamBaseX - beamTopWidth / 2,
            farSkyY,
            beamBaseX,
            beamBaseY,
            angle
          );
          const topRight = rotatePoint(
            beamBaseX + beamTopWidth / 2,
            farSkyY,
            beamBaseX,
            beamBaseY,
            angle
          );
          // Draw the beam as a single polygon (trapezoid) with constant faint alpha
          const searchlight = new PIXI.Graphics();
          searchlight.beginFill(0xffffcc, beamAlpha);
          searchlight.moveTo(baseLeft.x, baseLeft.y);
          searchlight.lineTo(baseRight.x, baseRight.y);
          searchlight.lineTo(topRight.x, topRight.y);
          searchlight.lineTo(topLeft.x, topLeft.y);
          searchlight.closePath();
          searchlight.endFill();
          searchlightContainer.addChild(searchlight);
        }

        // function drawBackdropCenterGlow() {
        //   // --- BACKDROP STARS ---
        //   function drawBackdropStars() {
        //     const starContainer = new PIXI.Container();
        //     const starCount = 32;
        //     // Find the highest background building Y (lowest y value)
        //     // We'll use a conservative estimate based on cityscape params
        //     const bgMaxHeight = 220;
        //     const bgBaseY = app.screen.height - 120;
        //     const highestBuildingY = bgBaseY - bgMaxHeight;
        //     for (let i = 0; i < starCount; i++) {
        //       const star = new PIXI.Graphics();
        //       // Random radius: 0.7 to 2.2 px
        //       const radius = 0.7 + Math.random() * 1.5;
        //       // Lower brightness: 0.32 to 0.62 (was 0.55-1.0)
        //       const alpha = 0.32 + Math.random() * 0.3;
        //       star.beginFill(0xffffff, alpha);
        //       star.drawCircle(0, 0, radius);
        //       star.endFill();
        //       // Random position above highest building
        //       star.x = Math.random() * app.screen.width;
        //       // Place in upper sky, but always above highest building
        //       const minY = 0;
        //       const maxY = highestBuildingY - 8;
        //       star.y = minY + Math.random() * (maxY - minY);
        //       starContainer.addChild(star);
        //     }
        //     // Add behind everything
        //     app.stage.addChildAt(starContainer, 0);
        //     window.backdropStars = starContainer;
        //   }
        //   drawBackdropStars();
        //
        //   // --- MOON OBJECT ---
        //   drawMoon(app);
        // }

        // --- ROUND SYSTEM ---
        let roundNumber = 1;
        let roundActive = false;
        let roundTimer = 0;
let roundDuration = 60 * 30; // 30 seconds at 60fps
        let roundPause = true;
        let roundFinishedText = null;
        // Scoring and round stats
        let rocketsDestroyed = 0;
        let buildingsDestroyed = 0;
        let enemyRocketInterval = 180; // frames between enemy rockets (3s at 60fps) - half frequency
        let enemyRocketFrameCounter = 0;
        let enemyRocketSpeed = 0.75; // Current enemy rocket speed (0.75 to 3.0)
        let friendlyRocketSpeed = 6; // Current friendly rocket speed (3 to 12)
        let starCount = 32; // Current star count (16 to 64)
        let searchlightWidth = 120; // Current searchlight beam width (60 to 240)        // --- PLAYER SCORE AND ROUND TIMER UI ---
        let playerScore = 0;
        // Score display (smaller, green, closer to top)
        const scoreDiv = document.createElement('div');
        scoreDiv.textContent = `Score: ${playerScore}`;
        scoreDiv.style.position = 'fixed';
        scoreDiv.style.top = '6px';
        scoreDiv.style.left = '50%';
        scoreDiv.style.transform = 'translateX(-50%)';
        scoreDiv.style.zIndex = '1500';
        scoreDiv.style.fontSize = '1.2rem';
        scoreDiv.style.fontWeight = 'bold';
        scoreDiv.style.color = '#00ff44';
        scoreDiv.style.textShadow = '0 1px 4px #000, 0 0px 2px #00ccff';
        scoreDiv.style.letterSpacing = '0.04em';
        scoreDiv.style.userSelect = 'none';
        document.body.appendChild(scoreDiv);

        // Round seconds-left display (smaller, green, closer to top left)
        const roundTimeDiv = document.createElement('div');
        roundTimeDiv.textContent = '';
        roundTimeDiv.style.position = 'fixed';
        roundTimeDiv.style.top = '6px';
        roundTimeDiv.style.left = '10px';
        roundTimeDiv.style.zIndex = '1500';
        roundTimeDiv.style.fontSize = '1.1rem';
        roundTimeDiv.style.fontWeight = 'bold';
        roundTimeDiv.style.color = '#00ff44';
        roundTimeDiv.style.textShadow = '0 1px 4px #000, 0 0px 2px #00ccff';
        roundTimeDiv.style.letterSpacing = '0.04em';
        roundTimeDiv.style.userSelect = 'none';
        document.body.appendChild(roundTimeDiv);

        // Fancy Start Round button
        const startRoundBtn = document.createElement('button');
        startRoundBtn.textContent = 'Start round 1';
        startRoundBtn.style.position = 'fixed';
        startRoundBtn.style.top = '50%';
        startRoundBtn.style.left = '50%';
        startRoundBtn.style.transform = 'translate(-50%, -50%)';
        startRoundBtn.style.zIndex = '2000';
        startRoundBtn.style.padding = '28px 64px';
        startRoundBtn.style.background = 'linear-gradient(90deg, #00ccff 0%, #ff00cc 100%)';
        startRoundBtn.style.color = '#fff';
        startRoundBtn.style.border = '4px solid #fff';
        startRoundBtn.style.borderRadius = '18px';
        startRoundBtn.style.fontSize = '2.2rem';
        startRoundBtn.style.cursor = 'pointer';
        startRoundBtn.style.boxShadow = '0 8px 32px rgba(0,0,0,0.28)';
        startRoundBtn.style.userSelect = 'none';
        startRoundBtn.style.fontWeight = 'bold';
        startRoundBtn.style.letterSpacing = '0.04em';
        startRoundBtn.style.display = 'block';
        startRoundBtn.style.transition = 'background 0.3s';
        startRoundBtn.addEventListener('mouseenter', () => {
          startRoundBtn.style.background = 'linear-gradient(90deg, #ff00cc 0%, #00ccff 100%)';
        });
        startRoundBtn.addEventListener('mouseleave', () => {
          startRoundBtn.style.background = 'linear-gradient(90deg, #00ccff 0%, #ff00cc 100%)';
        });
        document.body.appendChild(startRoundBtn);

        // Colorful round finished text with summary
        function showRoundFinishedText(round) {
          if (roundFinishedText) {
            roundFinishedText.remove();
            roundFinishedText = null;
          }
          // Calculate points (adjust values as needed)
          const pointsPerRocket = 100;
          const pointsPerBuilding = -200;
          console.log(`Rockets destroyed: ${rocketsDestroyed}, Buildings destroyed: ${buildingsDestroyed}`);
          const rocketsPoints = rocketsDestroyed * pointsPerRocket;
          console.log(`Rockets points: ${rocketsPoints}`);
          const buildingsPoints = buildingsDestroyed * pointsPerBuilding;
          const div = document.createElement('div');
          div.innerHTML = `Round ${round} finished<br><span style="font-size:1.3rem;">Rockets destroyed1: ${rocketsDestroyed} <span style='color:#00b800;font-size:1.1rem;'>(+${rocketsPoints})</span><br>Buildings destroyed: ${buildingsDestroyed} <span style='color:#d00000;font-size:1.1rem;'>(${buildingsPoints})</span></span>`;
          div.style.position = 'fixed';
          div.style.top = '50%';
          div.style.left = '50%';
          div.style.transform = 'translate(-50%, -50%)';
          div.style.zIndex = '2000';
          div.style.padding = '32px 80px';
          div.style.background = 'linear-gradient(90deg, #ffef00 0%, #ff00cc 100%)';
          div.style.color = '#222';
          div.style.border = '6px solid #fff';
          div.style.borderRadius = '22px';
          div.style.fontSize = '2.5rem';
          div.style.fontWeight = 'bold';
          div.style.boxShadow = '0 8px 32px rgba(0,0,0,0.28)';
          div.style.userSelect = 'none';
          div.style.letterSpacing = '0.04em';
          div.style.textAlign = 'center';
          div.style.display = 'block';
          document.body.appendChild(div);
          roundFinishedText = div;
        }

        function hideRoundFinishedText() {
          if (roundFinishedText) {
            roundFinishedText.remove();
            roundFinishedText = null;
          }
        }

        // Start round handler
        function startRound() {
          roundPause = false;
          roundActive = true;
          roundTimer = 0;
          rocketsDestroyed = 0;
          buildingsDestroyed = 0;
          // Reset destroyedBuildings state for new round
          destroyedBuildings = Array(buildingCenters.length).fill(false);
          hideRoundFinishedText();
          startRoundBtn.style.display = 'none';
        }

        // Stop round handler (same logic as when timer reaches duration)
        function stopRound() {
          // Only stop if a round is actually active
          if (!roundActive) return;
          
          // Destroy all remaining enemy rockets AS IF hit by friendly rockets (counts toward score)
          const remainingEnemyRockets = rockets.filter(r => !r.isPlayerRocket);
          for (const rocket of remainingEnemyRockets) {
            // Use the existing destroyEnemyRocketByPlayer function to get proper scoring and effects
            destroyEnemyRocketByPlayer(rocket, false);
          }
          
          // End round logic
          roundActive = false;
          roundPause = true;
          
          // Show round finished text and calculate score
          const pointsPerRocket = 100;
          const pointsPerBuilding = -200;
          const rocketsPoints = rocketsDestroyed * pointsPerRocket;
          const buildingsPoints = buildingsDestroyed * pointsPerBuilding;
          playerScore += rocketsPoints + buildingsPoints;
          scoreDiv.textContent = `Score: ${playerScore}`;
          showRoundFinishedText(roundNumber);
          
          // Prepare for next round
          roundNumber++;
          startRoundBtn.textContent = `Start round ${roundNumber}`;
          startRoundBtn.style.display = 'block';
        }

        startRoundBtn.addEventListener('click', () => {
          startRound();
        });

        // At game start, show the button
        startRoundBtn.textContent = `Start round ${roundNumber}`;
        startRoundBtn.style.display = 'block';

        // --- UI: Add a button to toggle searchlight (logic preserved, but button hidden for now) ---
        const toggleBtn = document.createElement('button');
        toggleBtn.textContent = 'Toggle Searchlight';
        // ...existing code...
        toggleBtn.style.display = 'none'; // Hide for now
        document.body.appendChild(toggleBtn);
        toggleBtn.addEventListener('click', () => {
          window._searchlightState.visible = !window._searchlightState.visible;
          drawSearchlight();
        });

        // --- Searchlight toggle every 600-900 frames, independent of round ---
        let searchlightFrameCounter = 0;
        let searchlightToggleInterval = 600 + Math.floor(Math.random() * 301); // 600-900 frames
        app.ticker.add(() => {
          // --- SEARCHLIGHT ANIMATION ---
          if (window._searchlightState.visible) {
            const maxAngle = Math.PI * 25 / 180; // 25 degrees in radians
            const state = window._searchlightState;
            
            // Update angle based on direction and speed
            state.angle += state.direction * state.speed;
            
            // Check bounds and reverse direction
            if (state.angle >= maxAngle) {
              state.angle = maxAngle;
              state.direction = -1; // Start moving left
            } else if (state.angle <= -maxAngle) {
              state.angle = -maxAngle;
              state.direction = 1; // Start moving right
            }
            
            // Redraw searchlight with new angle
            drawSearchlight();
          }

          // Round system logic
          if (roundActive) {
            roundTimer++;
            // Update round seconds-left UI
            const secondsLeft = Math.max(0, Math.ceil((roundDuration - roundTimer) / 60));
            roundTimeDiv.textContent = `Round: ${secondsLeft}s`;
            if (roundTimer >= roundDuration) {
              // COMMENTED OUT: Complex laser freeze logic
              /*
              // At round end, shoot red glowing lasers from antenna heads to each remaining enemy rocket, freezing them in place
              // Only enemy rockets (not player rockets) are frozen
              const unfrozenEnemyRockets = rockets.filter(r => !r.isPlayerRocket && !r.frozenByLaser);
              if (unfrozenEnemyRockets.length === 0) {
                // All enemy rockets already frozen, finish round logic but do NOT show end round dialog yet
                // (Removed white text dialog)
                // Do NOT set roundActive = false or roundPause = true here, and do NOT return; let the animation/game loop continue
              }
              // Laser animation state
              if (!window._laserFreezeState) {
                window._laserFreezeState = {
                  queue: rockets.filter(r => !r.isPlayerRocket && !r.frozenByLaser),
                  antennaToggle: 0, // 0 = left, 1 = right
                  // Remove laserContainer, lasers will be added directly to app.stage
                };
                // No laserContainer needed
              }
              const state = window._laserFreezeState;
              // Only process one enemy rocket per frame
              if (state.queue.length > 0) {
                const rocket = state.queue.shift();
                // ... all the complex antenna calculation and laser logic ...
              }
              */
              
              // SIMPLIFIED: Destroy all remaining enemy rockets AS IF hit by friendly rockets (counts toward score)
              const remainingEnemyRockets = rockets.filter(r => !r.isPlayerRocket);
              for (const rocket of remainingEnemyRockets) {
                // Use the existing destroyEnemyRocketByPlayer function to get proper scoring and effects
                destroyEnemyRocketByPlayer(rocket, false);
              }
              
              // End round logic
              roundActive = false;
              roundPause = true;
              
              // Show round finished text and calculate score
              const pointsPerRocket = 100;
              const pointsPerBuilding = -200;
              const rocketsPoints = rocketsDestroyed * pointsPerRocket;
              const buildingsPoints = buildingsDestroyed * pointsPerBuilding;
              playerScore += rocketsPoints + buildingsPoints;
              scoreDiv.textContent = `Score: ${playerScore}`;
              showRoundFinishedText(roundNumber);
              
              // Prepare for next round
              roundNumber++;
              startRoundBtn.textContent = `Start round ${roundNumber}`;
              startRoundBtn.style.display = 'block';
            }
          } else {
            // Hide timer if not in round
            roundTimeDiv.textContent = '';
          }
          // Pause all game logic if not in round (except searchlight toggle)
          if (!roundActive) return;
        });

        // COMMENTED OUT: Laser animation container and logic
        /*
        // --- LASER ANIMATION: Draw all active lasers in main loop using a container (like searchlight) ---
        const laserContainer = new PIXI.Container();
        // Always add as the last child after all other stage children are created
        app.stage.addChild(laserContainer);
        laserContainer.alpha = 1.0;
        laserContainer.blendMode = 'normal';

        app.ticker.add(() => {
          // Remove previous lasers
          laserContainer.removeChildren();

          // Draw each laser as a thin solid red rectangle between its endpoints
          if (window.activeLasers && window.activeLasers.length > 0) {
            for (const laser of window.activeLasers) {
              // ... all the laser animation logic ...
            }
          }

          // Ensure laserContainer is always the topmost child
          if (app.stage.children[app.stage.children.length - 1] !== laserContainer) {
            app.stage.addChild(laserContainer);
          }
          laserContainer.zIndex = 9999;
          if (!app.stage.sortableChildren) app.stage.sortableChildren = true;
        });
        */

        // Separate ticker for searchlight toggle (always runs)
        app.ticker.add(() => {
          searchlightFrameCounter = (Number(searchlightFrameCounter) || 0) + 1;
          if (searchlightFrameCounter >= searchlightToggleInterval) {
            searchlightFrameCounter = 0;
            window._searchlightState.visible = !window._searchlightState.visible;
            drawSearchlight();
            searchlightToggleInterval = 600 + Math.floor(Math.random() * 301); // 600-900 frames
          }
        });
        
        // Enemy rocket creation now in enemyRocket.js
        
        // Add keyboard handler to create rockets, test enemy explosion, and show combo effect
// Removed 'K' key handler for combo test
let comboTextSprite = null;

        // Add click handler to launch a green rocket from bunker roof towards mouse click
        app.canvas.addEventListener('click', (event) => {
          if (event.button === 0) {
            // Disable firing if round is not active or if round has ended (no new friendly rockets after roundTimer >= roundDuration)
            if (!roundActive || roundTimer >= roundDuration) return;
            // Friendly rocket limit logic
            if (availableFriendlyRockets <= 0) {
              // Optionally: play a sound or flash icons
              return;
            }
            // Get mouse position relative to canvas
            const rect = app.canvas.getBoundingClientRect();
            const mouseX = (event.clientX - rect.left) * (app.screen.width / rect.width);
            const mouseY = (event.clientY - rect.top) * (app.screen.height / rect.height);
            // Assign a unique explosionId for combo tracking
            const explosionId = nextExplosionId++;
            createFriendlyRocket(app, rockets, centerX, bottomY, bunkerHeight, mouseX, mouseY, explosionId, MAX_FRIENDLY_ROCKETS, rocketIconsState, availableFriendlyRockets, drawRocketIcons, startRocketCooldown, friendlyRocketSpeed);
          }
        });

        // Add right-click handler to launch a targeted rocket (DISABLED, keep code for future testing)
        // app.canvas.addEventListener('contextmenu', (event) => {
        //   event.preventDefault(); // Prevent context menu
        //   // Pick a random building
        //   const buildingIdx = Math.floor(Math.random() * buildingCenters.length);
        //   const buildingCenterX = buildingCenters[buildingIdx] + buildingWidth / 2;
        //   const buildingTopY = bottomY - buildingHeight;
        //   // Spawn rocket at random X at top
        //   const rocketStartX = Math.random() * app.screen.width;
        //   const rocketStartY = 0;
        //   // Calculate velocity to aim at building
        //   const dx = buildingCenterX - rocketStartX;
        //   const dy = buildingTopY - rocketStartY;
        //   const dist = Math.sqrt(dx * dx + dy * dy);
        //   const speed = 1.5; // Slower enemy rocket speed
        //   const vx = dx / dist * speed;
        //   const vy = dy / dist * speed;
        //   // Create rocket
        //   const rocket = new PIXI.Graphics();
        //   rocket.beginFill(0xFF2222); // Red for enemy rocket
        //   rocket.drawCircle(0, 0, 3);
        //   rocket.endFill();
        //   rocket.x = rocketStartX;
        //   rocket.y = rocketStartY;
        //   rocket.vx = vx;
        //   rocket.vy = vy;
        //   rocket.trail = [];
        //   rocket.maxTrailLength = 25;
        //   rocket.targetBuildingIdx = buildingIdx;
        //   rocket.targetX = buildingCenterX;
        //   rocket.targetY = buildingTopY;
        //   rockets.push(rocket);
        //   app.stage.addChild(rocket);
        // });
        // --- Automatic enemy rocket firing during active round ---
        app.ticker.add(() => {
          if (!roundActive) return;
          // Prevent new enemy rockets from spawning after round end (when roundTimer >= roundDuration)
          if (roundTimer >= roundDuration) return;
          enemyRocketFrameCounter++;
          if (enemyRocketFrameCounter >= enemyRocketInterval) {
            enemyRocketFrameCounter = 0;
            spawnEnemyRocket(app, rockets, buildingCenters, buildingWidth, buildingHeight, bottomY, enemyRocketSpeed);
          }
        });

        // Explosion function (no-op, left for compatibility)
        function explodeBuilding() {
          // No action; buildings only explode when hit by a rocket
        }

        // Explosion function for a specific building
        function explodeBuildingAt(buildingIdx) {
          // Prevent double-destruction
          if (destroyedBuildings[buildingIdx]) return;
          destroyedBuildings[buildingIdx] = true;
          console.log('Exploding building at index:', buildingIdx);
          buildingsDestroyed++;
          playerScore -= 500;
          scoreDiv.textContent = `Score: ${playerScore}`;
          // Find all pieces belonging to this building (by gridX/gridY and position)
          buildingPieces.forEach((piece) => {
            if (
              piece.originalX >= buildingCenters[buildingIdx] &&
              piece.originalX < buildingCenters[buildingIdx] + buildingWidth
            ) {
              // Explode this piece
              piece.vx = (Math.random() - 0.5) * 3.0;
              piece.vy = -(4.0 + Math.random() * 3.2);
              piece.rotationSpeed = (Math.random() - 0.5) * 0.1;
              piece.exploding = true;
              piece.landed = false;
              piece.bounced = false;
            }
          });
          // Center explosion at building base
          const x = buildingCenters[buildingIdx] + buildingWidth / 2;
          const y = bottomY;
          createExplosionParticles(x, y);
        }
        // --- Add scoring for enemy rocket destruction by player ---

        // Combo detection: track which player explosion destroyed which enemy rockets
        // Map: explosionId -> { count, x, y, lastComboShown }
        const playerExplosionCombos = {};
        let nextExplosionId = 1;

        // Helper to show combo text at (x, y) with given combo count
        function showComboText(comboCount, x, y) {
  if (comboCount < 2) return;
  // Remove previous combo text if present
  if (window.comboTextSprite) {
    app.stage.removeChild(window.comboTextSprite);
    window.comboTextSprite = null;
  }
  // Use a single solid color (yellow) for combo text
  const fontSize = 24 + Math.min(20, (comboCount - 2) * 4);
  const comboText = new PIXI.Text(`X${comboCount} Combo`, {
    fontFamily: 'Arial Black, Arial, sans-serif',
    fontSize: fontSize,
    fill: 0xffff00,
    fontWeight: 'bold',
    stroke: '#ff8800',
    strokeThickness: 6,
    dropShadow: true,
    dropShadowColor: '#222',
    dropShadowBlur: 8,
    dropShadowDistance: 0,
    align: 'center',
  });
  comboText.anchor.set(0.5, 0.5);
  comboText.x = x;
  comboText.y = y + 32; // Show below the explosion
  comboText.alpha = 1.0;
  app.stage.addChild(comboText);
  window.comboTextSprite = comboText;
  // Animate fade out and movement over 1.2s
  const fadeDuration = 72; // frames at 60fps
  let fadeFrame = 0;
  const startX = comboText.x;
  const startY = comboText.y;
  const isLeft = startX < app.screen.width / 2;
  const dx = (isLeft || startX === app.screen.width / 2) ? 40 : -40;
  const dy = 40;
  function fadeCombo() {
    fadeFrame++;
    if (!window.comboTextSprite) return;
    const t = fadeFrame / fadeDuration;
    window.comboTextSprite.alpha = 1 - t;
    window.comboTextSprite.x = startX + dx * t;
    window.comboTextSprite.y = startY + dy * t;
    if (fadeFrame < fadeDuration) {
      requestAnimationFrame(fadeCombo);
    } else {
      if (window.comboTextSprite) {
        app.stage.removeChild(window.comboTextSprite);
        window.comboTextSprite = null;
      }
    }
  }
  fadeCombo();
        }

        // Unified function: destroy enemy rocket as if hit by friendly rocket explosion
        // If destroyed by player, pass explosionId to track combos
        function destroyEnemyRocketByPlayer(rocket, byPlayer = true, explosionId = null) {
          createRedBurstExplosion(rocket.x, rocket.y);
          app.stage.removeChild(rocket);
          if (rocket.trail) rocket.trail.forEach(trail => app.stage.removeChild(trail));
          const idx = rockets.indexOf(rocket);
          if (idx !== -1) rockets.splice(idx, 1);
          if (byPlayer) {
            rocketsDestroyed++;
            let comboBonus = 0;
            // Combo logic
            if (explosionId) {
              if (!playerExplosionCombos[explosionId]) {
                playerExplosionCombos[explosionId] = { count: 0, x: rocket.x, y: rocket.y, lastComboShown: 0 };
              }
              const combo = playerExplosionCombos[explosionId];
              combo.count++;
              // Combo bonus: for 2x combo, +200; 3x combo, +300, etc. (in addition to base 100)
              if (combo.count >= 2) {
                comboBonus = combo.count * 100;
              }
              // Show combo text only when count >= 2 and only if this is a new max
              if (combo.count >= 2 && combo.count > combo.lastComboShown) {
                showComboText(combo.count, combo.x, combo.y);
                combo.lastComboShown = combo.count;
              }
            }
            playerScore += 100 + comboBonus;
            scoreDiv.textContent = `Score: ${playerScore}`;
          }
        }

        // Generic explosion function that can be called from anywhere
        function explodeAtPosition(x, y) {
          // Create explosion particles at specified position
          createExplosionParticles(x, y);
          
          buildingPieces.forEach((piece, index) => {
            // Random horizontal speed anywhere from -1.5 to +1.5 (including zero for straight up)
            piece.vx = (Math.random() - 0.5) * 3.0; // -1.5 to +1.5 pixels per frame
            
            // Random slow vertical speed (upward) - halved max velocity with offset
            piece.vy = -(4.0 + Math.random() * 3.2); // -4.0 to -7.2 pixels per frame (negative = upward)
            
            // Random rotation speed
            piece.rotationSpeed = (Math.random() - 0.5) * 0.1; // -0.05 to 0.05 radians per frame
            
            // Mark as exploding
            piece.exploding = true;
            piece.landed = false;
            piece.bounced = false; // Track if piece has bounced yet
          });
        }

        // Create explosion particles for building destruction (restored original counts)
        function createExplosionParticles(explosionCenterX = centerX, explosionCenterY = bottomY) {
          // Create fire/spark particles (original: 100)
          for (let i = 0; i < 100; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
           
            const speed = 1.5 + Math.random() * 9;
            const size = 1 + Math.random() * 6;
            const colors = [0xFF4500, 0xFF6600, 0xFF8C00, 0xFFD700, 0xFFFFFF];
            const color = colors[Math.floor(Math.random() * colors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX;
            particle.y = explosionCenterY;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = -Math.random() * 10;
            particle.life = 1.0;
            particle.maxLife = 60 + Math.random() * 60;
            particle.type = 'fire';
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
          // Create sparkle particles (original: 100)
          for (let i = 0; i < 100; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 4;
            const size = 1 + Math.random() * 4;
            const sparkleColors = [0x00FFFF, 0xFFFFFF, 0xFFD700, 0xFF69B4];
            const color = sparkleColors[Math.floor(Math.random() * sparkleColors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX;
            particle.y = explosionCenterY;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = -Math.random() * 5;
            particle.life = 1.0;
            particle.maxLife = 40 + Math.random() * 40;
            particle.type = 'sparkle';
            particle.twinkle = Math.random() * Math.PI * 2;
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
          // Create yellow spark cloud (original: 400)
          for (let i = 0; i < 400; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 3.0;
            const size = 1 + Math.random() * 3;
            const yellowColors = [0xFFFF00, 0xFFD700, 0xFFA500, 0xFFFF99, 0xFFE135];
            const color = yellowColors[Math.floor(Math.random() * yellowColors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX + (Math.random() - 0.5) * 20;
            particle.y = explosionCenterY + (Math.random() - 0.5) * 20;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed - 1;
            particle.life = 1.0;
            particle.maxLife = 120 + Math.random() * 80;
            particle.type = 'yellowCloud';
            particle.flickerPhase = Math.random() * Math.PI * 2;
            particle.expansion = 0;
            particle.gravity = 0.01 + Math.random() * 0.02;
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
        }

        // Create explosion particles for enemy rocket explosions (reduced counts)
        function createEnemyRocketExplosionParticles(explosionCenterX, explosionCenterY) {
          // Create fire/spark particles (360)
          for (let i = 0; i < 360; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 9;
            const size = 1 + Math.random() * 6;
            const colors = [0xFF4500, 0xFF6600, 0xFF8C00, 0xFFD700, 0xFFFFFF];
            const color = colors[Math.floor(Math.random() * colors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX;
            particle.y = explosionCenterY;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = -Math.random() * 10;
            particle.life = 1.0;
            particle.maxLife = 60 + Math.random() * 60;
            particle.type = 'fire';
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
          // Create sparkle particles (160)
          for (let i = 0; i < 160; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 4;
            const size = 1 + Math.random() * 4;
            const sparkleColors = [0x00FFFF, 0xFFFFFF, 0xFFD700, 0xFF69B4];
            const color = sparkleColors[Math.floor(Math.random() * sparkleColors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX;
            particle.y = explosionCenterY;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = -Math.random() * 5;
            particle.life = 1.0;
            particle.maxLife = 40 + Math.random() * 40;
            particle.type = 'sparkle';
            particle.twinkle = Math.random() * Math.PI * 2;
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
          // Create yellow spark cloud (800)
          for (let i = 0; i < 800; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.25 + Math.random() * 1.5;
            const size = 1 + Math.random() * 3;
            const yellowColors = [0xFFFF00, 0xFFD700, 0xFFA500, 0xFFFF99, 0xFFE135];
            const color = yellowColors[Math.floor(Math.random() * yellowColors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX + (Math.random() - 0.5) * 20;
            particle.y = explosionCenterY + (Math.random() - 0.5) * 20;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed - 1.5;
            particle.life = 1.0;
            particle.maxLife = 240 + Math.random() * 160;
            particle.type = 'yellowCloud';
            particle.flickerPhase = Math.random() * Math.PI * 2;
            particle.expansion = 0;
            particle.gravity = 0.02 + Math.random() * 0.04;
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
        }

        // Animation loop for exploding pieces
        // Create a red/yellow/orange burst explosion with trails (for enemy rocket destruction)
        function createRedBurstExplosion(x, y) {
          const burstCount = 4 * (25 + Math.floor(Math.random() * 11)); // 100-140 particles
          for (let i = 0; i < burstCount; i++) {
            const particle = new PIXI.Graphics();
            // Red/yellow/orange colors
            const colors = [0xFF2222, 0xFF6600, 0xFFAA00, 0xFFD700, 0xFF8800];
            const color = colors[Math.floor(Math.random() * colors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, 1 + Math.random() * 1.2); // Smaller size
            particle.endFill();
            particle.x = x;
            particle.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.7 + Math.random() * 2.1; // Slightly slower
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;
            particle.type = 'redBurst';
            particle.trail = [];
            particle.maxTrailLength = 12 + Math.floor(Math.random() * 8);
            particle.life = 1.0;
            particle.maxLife = 40 + Math.random() * 40; // 40-80 frames (shorter lifetime)
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
          // Also spawn a small bright white sparkle explosion at the same location
          createWhiteSparkleExplosion(x, y);
        }

        // Create a small bright white sparkle explosion (100 particles, slow outward, like player rocket sparkle)
        function createWhiteSparkleExplosion(x, y) {
          const count = 320;
          for (let i = 0; i < count; i++) {
            const particle = new PIXI.Graphics();
            // White color for sparkle
            particle.beginFill(0xFFFFFF);
            particle.drawCircle(0, 0, 1.5 + Math.random() * 1.5);
            particle.endFill();
            particle.x = x;
            particle.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.2 + Math.random() * 1.3; // Wider range, slower minimum
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;
            particle.life = 1.0;
            particle.maxLife = 40 + Math.random() * 30; // 40-70 frames
            particle.type = 'whiteSparkle';
            particle.twinkle = Math.random() * Math.PI * 2;
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
        }

// Create a small grey dud explosion (50 particles, slow outward, for dud effect)
function createGreyDudExplosion(x, y) {
  const count = 32;
  for (let i = 0; i < count; i++) {
    const particle = new PIXI.Graphics();
    // Darker grey color for dud
    const greyShades = [0x222222, 0x333333, 0x444444, 0x555555, 0x666666];
    const color = greyShades[Math.floor(Math.random() * greyShades.length)];
    particle.beginFill(color);
    particle.drawCircle(0, 0, 1.2 + Math.random() * 1.8);
    particle.endFill();
    particle.x = x;
    particle.y = y;
    const angle = Math.random() * Math.PI * 2;
    const speed = 0.4 + Math.random() * 1.2;
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.life = 1.0;
    particle.maxLife = 24 + Math.random() * 18; // 24-42 frames
    particle.type = 'greyDud';
    explosionParticles.push(particle);
    app.stage.addChild(particle);
  }
}
        // Create a growing spark cloud at (x, y) with given final radius, particle count, and duration (frames)
        function createGrowingSparkCloud(centerX, centerY, finalRadius, particleCount, durationFrames) {
          // Accept explosionId as an optional argument (for player explosions)
          let explosionId = null;
          if (arguments.length >= 6) {
            explosionId = arguments[5];
          }
          // Track this explosion's state
          const explosion = {
            centerX,
            centerY,
            finalRadius,
            durationFrames,
            frame: 0,
            particles: [],
            currentRadius: 0,
            explosionId: explosionId || null
          };
          for (let i = 0; i < particleCount; i++) {
            const particle = new PIXI.Graphics();
            // Start at center
            particle.x = centerX;
            particle.y = centerY;
            // Store explosion center for animation
            particle.growCenterX = centerX;
            particle.growCenterY = centerY;
            // Angle and final distance
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * finalRadius;
            // Color: use yellow spark colors
            const yellowColors = [0xFFFF00, 0xFFD700, 0xFFA500, 0xFFFF99, 0xFFE135];
            const color = yellowColors[Math.floor(Math.random() * yellowColors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, 0.8 + Math.random() * 1.2); // Smaller size
            particle.endFill();
            // Animate outward over durationFrames
            particle.growAngle = angle;
            particle.growDistance = distance;
            particle.growFrame = 0;
            particle.growDuration = durationFrames;
            particle.type = 'growingSpark';
            particle.alpha = 1.0;
            // Flicker like sparkle
            particle.twinkle = Math.random() * Math.PI * 2;
            explosionParticles.push(particle);
            explosion.particles.push(particle);
            app.stage.addChild(particle);
          }
          activePlayerExplosions.push(explosion);
        }

        app.ticker.add(() => {
          // Update rockets
          for (let i = rockets.length - 1; i >= 0; i--) {
            const rocket = rockets[i];
            // Move rocket
            rocket.x += rocket.vx;
            rocket.y += rocket.vy;
            // Create trail particle at current position
            const trailParticle = new PIXI.Graphics();
            if (rocket.isPlayerRocket) {
              trailParticle.beginFill(0x00ff44); // Green for player rocket trail
            } else {
              trailParticle.beginFill(0xFF2222); // Red for enemy rocket trail
            }
            trailParticle.drawCircle(0, 0, 3);
            trailParticle.endFill();
            trailParticle.x = rocket.x;
            trailParticle.y = rocket.y;
            trailParticle.alpha = 1.0;
            trailParticle.age = 0;
            rocket.trail.push(trailParticle);
            app.stage.addChild(trailParticle);
            // Update trail particles
            for (let j = rocket.trail.length - 1; j >= 0; j--) {
              const trail = rocket.trail[j];
              trail.age++;
              const ageRatio = trail.age / rocket.maxTrailLength;
              const size = 3 - (ageRatio * 2);
              trail.scale.set(size / 3);
              trail.alpha = 1.0 - (ageRatio * 0.95);
              if (trail.age >= rocket.maxTrailLength) {
                app.stage.removeChild(trail);
                rocket.trail.splice(j, 1);
              }
            }
            // Check if rocket hit its target building (for targeted rockets)
            if (rocket.targetBuildingIdx !== undefined) {
              // Building bounding box
              const bIdx = rocket.targetBuildingIdx;
              const bx = buildingCenters[bIdx];
              const by = bottomY - buildingHeight;
              if (
                rocket.x >= bx &&
                rocket.x <= bx + buildingWidth &&
                rocket.y >= by &&
                rocket.y <= by + buildingHeight
              ) {
                // Use destroyedBuildings array for reliable destroyed state
                if (!destroyedBuildings[bIdx]) {
                  explodeBuildingAt(bIdx);
                } // else: already destroyed, just remove rocket silently
  else {
    // Show dud explosion at rocket position
    createGreyDudExplosion(rocket.x, rocket.y);
  }
                app.stage.removeChild(rocket);
                rocket.trail.forEach(trail => app.stage.removeChild(trail));
                rockets.splice(i, 1);
                continue;
              }


            } else if (rocket.isPlayerRocket) {
              // Player rocket: check if reached mouse target (within 8px)
              const dx = rocket.x - rocket.targetX;
              const dy = rocket.y - rocket.targetY;
              if (Math.sqrt(dx * dx + dy * dy) < 8) {
                // Create a large growing spark cloud at mouse target (200 particles, smaller, flicker)
                createGrowingSparkCloud(rocket.targetX, rocket.targetY, 50, 200, 120, rocket.explosionId); // Pass explosionId for combo tracking
                app.stage.removeChild(rocket);
                rocket.trail.forEach(trail => app.stage.removeChild(trail));
                rockets.splice(i, 1);
                continue;
              }
            } else {
              // Old rockets: check if hit any building area
              if (rocket.y >= bottomY - buildingHeight) {
                //explodeAtPosition(centerX, bottomY);
                app.stage.removeChild(rocket);
                rocket.trail.forEach(trail => app.stage.removeChild(trail));
                rockets.splice(i, 1);
                continue;
              }
            }
            // Remove rocket if it goes off screen
            if (rocket.y > app.screen.height + 50) {
              app.stage.removeChild(rocket);
              rocket.trail.forEach(trail => app.stage.removeChild(trail));
              rockets.splice(i, 1);
            }
          }
          
          // Update building pieces
          buildingPieces.forEach((piece) => {
            if (piece.exploding && !piece.landed) {
              // Apply gravity to vertical speed
              piece.vy += 0.08; // Gravity constant
              
              // Apply rotation
              piece.rotation += piece.rotationSpeed;
              
              // Calculate next position
              const nextX = piece.x + piece.vx;
              const nextY = piece.y + piece.vy;
              
              // Check for first bounce at ground level
              if (nextY + pieceHeight >= app.screen.height && piece.vy > 0 && !piece.bounced) {
                // First bounce only - then let them fall off screen
                piece.x = nextX; // Update horizontal position
                piece.y = app.screen.height - pieceHeight; // Snap to ground for bounce
                piece.vy = -piece.vy * 0.4; // Reverse and reduce vertical velocity (40% of impact speed)
                piece.vx = piece.vx * 0.7; // Reduce horizontal velocity due to friction
                piece.rotationSpeed *= 0.6; // Reduce rotation speed
                piece.bounced = true; // Mark as having bounced
              } else {
                // Normal position update - let pieces fall off screen after bounce
                piece.x = nextX;
                piece.y = nextY;
                
                // Mark as landed (for cleanup) if piece is far off screen
                if (piece.y > app.screen.height + 200) {
                  piece.landed = true; // Will be cleaned up below
                }
              }
            }
          });
          
          // Clean up pieces that have fallen off screen
          for (let i = buildingPieces.length - 1; i >= 0; i--) {
            const piece = buildingPieces[i];
            if (piece.landed) {
              app.stage.removeChild(piece);
              buildingPieces.splice(i, 1);
            }
          }
          
          // Update explosion particles and track growing player explosions
          for (let i = explosionParticles.length - 1; i >= 0; i--) {
            const particle = explosionParticles[i];
            if (particle.type === 'growingSpark') {
              // Animate outward from center to final radius over duration
              particle.growFrame++;
              const t = Math.min(1, particle.growFrame / particle.growDuration);
              // Ease out for more natural look
              const easeT = 1 - Math.pow(1 - t, 2);
              const r = easeT * particle.growDistance;
              particle.x = particle.growCenterX + Math.cos(particle.growAngle) * r;
              particle.y = particle.growCenterY + Math.sin(particle.growAngle) * r;
              // Flicker like sparkle
              particle.twinkle += 0.3;
              const flicker = 0.5 + 0.5 * Math.sin(particle.twinkle);
              particle.alpha = (1.0 - t * 0.7) * flicker;
              // Remove after duration
              if (particle.growFrame >= particle.growDuration) {
                app.stage.removeChild(particle);
                explosionParticles.splice(i, 1);
                // Remove from activePlayerExplosions if this was the last particle
                for (let e = activePlayerExplosions.length - 1; e >= 0; e--) {
                  const exp = activePlayerExplosions[e];
                  if (exp.particles.includes(particle)) {
                    // Remove this particle from the explosion's list
                    exp.particles = exp.particles.filter(p => p !== particle);
                    // If no particles left, remove the explosion
                    if (exp.particles.length === 0) {
                      activePlayerExplosions.splice(e, 1);
                    }
                    break;
                  }
                }
                continue;
              }
              continue;
            }
            if (particle.type === 'redBurst') {
              // Move
              particle.x += particle.vx;
              particle.y += particle.vy;
              // Fade out
              particle.life -= 1 / particle.maxLife;
              particle.alpha = particle.life;
              // Add trail particle
              const trailParticle = new PIXI.Graphics();
              trailParticle.beginFill(0xFF6600);
              trailParticle.drawCircle(0, 0, 1.2);
              trailParticle.endFill();
              trailParticle.x = particle.x;
              trailParticle.y = particle.y;
              trailParticle.alpha = 0.7;
              trailParticle.age = 0;
              particle.trail.push(trailParticle);
              app.stage.addChild(trailParticle);
              // Update and clean up trail
              for (let t = particle.trail.length - 1; t >= 0; t--) {
                const tr = particle.trail[t];
                tr.age++;
                tr.alpha = 0.7 * (1 - tr.age / particle.maxTrailLength);
                tr.scale.set(1 - tr.age / particle.maxTrailLength);
                if (tr.age >= particle.maxTrailLength) {
                  app.stage.removeChild(tr);
                  particle.trail.splice(t, 1);
                }
              }
              // Remove main particle if dead
              if (particle.life <= 0 || particle.alpha <= 0) {
                // Remove all trail particles
                particle.trail.forEach(tr => app.stage.removeChild(tr));
                app.stage.removeChild(particle);
                explosionParticles.splice(i, 1);
                continue;
              }
              continue;
            }
            // Animate white sparkle explosion
            if (particle.type === 'whiteSparkle') {
              particle.x += particle.vx;
              particle.y += particle.vy;
              particle.life -= 1 / particle.maxLife;
              particle.twinkle += 0.3;
              const flicker = 0.7 + 0.3 * Math.sin(particle.twinkle * 2);
              particle.alpha = particle.life * flicker;
              particle.vx *= 0.97;
              particle.vy *= 0.97;
              if (particle.life <= 0 || particle.alpha <= 0) {
                app.stage.removeChild(particle);
                explosionParticles.splice(i, 1);
                continue;
              }
              continue;
            }
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.life -= 1 / particle.maxLife;
            if (particle.type === 'fire') {
              particle.vy += 0.05;
              particle.alpha = particle.life;
              particle.scale.set(particle.life);
              particle.vx *= 0.98;
              particle.vy *= 0.98;
            } else if (particle.type === 'sparkle') {
              particle.vy += 0.08;
              particle.twinkle += 0.3;
              particle.alpha = particle.life * (0.5 + 0.5 * Math.sin(particle.twinkle));
              particle.vx *= 0.95;
            } else if (particle.type === 'yellowCloud') {
              particle.expansion += 0.02;
              particle.vx *= 1.01;
              particle.vy += particle.gravity;
              particle.vx *= 0.995;
              particle.vy *= 0.998;
              particle.flickerPhase += 0.4;
              const flicker = 0.6 + 0.4 * Math.sin(particle.flickerPhase);
              particle.alpha = particle.life * flicker;
              const scaleVariation = 0.8 + 0.2 * Math.sin(particle.flickerPhase * 0.7);
              particle.scale.set(particle.life * scaleVariation);
            }
            if (particle.life <= 0 || particle.alpha <= 0) {
              app.stage.removeChild(particle);
              explosionParticles.splice(i, 1);
            }
          }

          // Update currentRadius for each active player explosion
          for (let e = activePlayerExplosions.length - 1; e >= 0; e--) {
            const exp = activePlayerExplosions[e];
            exp.frame++;
            const t = Math.min(1, exp.frame / exp.durationFrames);
            const easeT = 1 - Math.pow(1 - t, 2);
            exp.currentRadius = easeT * exp.finalRadius;
          }

          // Destroy enemy rockets that enter any active player explosion radius
          for (let i = rockets.length - 1; i >= 0; i--) {
            const rocket = rockets[i];
            if (rocket.isPlayerRocket) continue;
            for (let e = 0; e < activePlayerExplosions.length; e++) {
              const exp = activePlayerExplosions[e];
              const dx = rocket.x - exp.centerX;
              const dy = rocket.y - exp.centerY;
              if (Math.sqrt(dx * dx + dy * dy) < exp.currentRadius) {
                destroyEnemyRocketByPlayer(rocket, true, exp.explosionId);
                break;
              }
            }
          }
        });


      });
    </script>
  </body>
</html>
