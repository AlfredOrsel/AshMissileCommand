<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clean PixiJS Project</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #app {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      canvas {
        display: block;
        width: 100% !important;
        height: 100% !important;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.0.0/dist/pixi.min.js"></script>
    <script>
      // Create the PixiJS application
      const app = new PIXI.Application();
      
      // Initialize the application
      app.init({
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: 0x000000, // Black background
        antialias: true,
      }).then(() => {
        // Add the canvas to the DOM after initialization
        document.getElementById('app').appendChild(app.canvas);

        // Handle window resize
        window.addEventListener('resize', () => {
          app.renderer.resize(window.innerWidth, window.innerHeight);
        });

        // Add to window for debugging
        window.app = app;


        // --- BACKDROP: Center Glow Ball ---


        function drawBackdropCenterGlow() {
          // --- BACKDROP STARS ---
          function drawBackdropStars() {
            const starContainer = new PIXI.Container();
            const starCount = 32;
            // Find the highest background building Y (lowest y value)
            // We'll use a conservative estimate based on cityscape params
            const bgMaxHeight = 220;
            const bgBaseY = app.screen.height - 120;
            const highestBuildingY = bgBaseY - bgMaxHeight;
            for (let i = 0; i < starCount; i++) {
              const star = new PIXI.Graphics();
              // Random radius: 0.7 to 2.2 px
              const radius = 0.7 + Math.random() * 1.5;
              // Lower brightness: 0.32 to 0.62 (was 0.55-1.0)
              const alpha = 0.32 + Math.random() * 0.3;
              star.beginFill(0xffffff, alpha);
              star.drawCircle(0, 0, radius);
              star.endFill();
              // Random position above highest building
              star.x = Math.random() * app.screen.width;
              // Place in upper sky, but always above highest building
              const minY = 0;
              const maxY = highestBuildingY - 8;
              star.y = minY + Math.random() * (maxY - minY);
              starContainer.addChild(star);
            }
            // Add behind everything
            app.stage.addChildAt(starContainer, 0);
            window.backdropStars = starContainer;
          }
          drawBackdropStars();

          // --- MOON OBJECT ---
          function drawMoon() {
            const moonContainer = new PIXI.Container();
            // Position: top right, with some margin
            const margin = Math.min(app.screen.width, app.screen.height) * 0.07;
            const moonRadius = Math.min(app.screen.width, app.screen.height) * 0.035; // even smaller
            const moonX = app.screen.width - margin - moonRadius;
            const moonY = margin + moonRadius;
            // Glow (restored original, stronger)
            const moonGlow = new PIXI.Graphics();
            for (let r = moonRadius * 1.7; r > moonRadius; r -= 1.2) {
              const t = (r - moonRadius) / (moonRadius * 0.7);
              const alpha = 0.18 * Math.pow(1 - t, 2.5);
              if (alpha < 0.01) continue;
              moonGlow.beginFill(0xffffff, alpha);
              moonGlow.drawCircle(0, 0, r);
              moonGlow.endFill();
            }
            moonGlow.x = 0;
            moonGlow.y = 0;
            moonContainer.addChild(moonGlow);
            // Core (main moon disk)
            const moonCore = new PIXI.Graphics();
            moonCore.beginFill(0xffffff, 0.98);
            moonCore.drawCircle(0, 0, moonRadius);
            moonCore.endFill();
            moonCore.x = 0;
            moonCore.y = 0;
            moonContainer.addChild(moonCore);
            // Place moon
            moonContainer.x = moonX;
            moonContainer.y = moonY;
            app.stage.addChildAt(moonContainer, 0);
            window.moon = moonContainer;
          }
          drawMoon();

          // --- Unified Star Object (core, glow, spikes, ring) ---
          function makeUnifiedStar(extraDirections = []) {
            const star = new PIXI.Container();
            // Glow (less bright)
            const glow = new PIXI.Graphics();
            const glowRadius = Math.min(app.screen.width, app.screen.height) * 0.027;
            const coreRadius = Math.max(0.5, glowRadius * 0.09);
            for (let r = glowRadius; r > 0; r -= 0.5) {
              const t = r / glowRadius;
              const alpha = 0.13 * Math.pow(1 - t, 2.5); // was 0.28
              if (alpha < 0.003) continue;
              glow.beginFill(0xffffff, alpha);
              glow.drawCircle(0, 0, r);
              glow.endFill();
            }
            glow.x = 0;
            glow.y = 0;
            star.addChild(glow);
            // Core (less bright)
            const core = new PIXI.Graphics();
            core.beginFill(0xffffff, 0.32); // was 0.68
            core.drawCircle(0, 0, coreRadius);
            core.endFill();
            core.x = 0;
            core.y = 0;
            star.addChild(core);
            // Spikes (less bright)
            const spikeLength = glowRadius * 2.45 * 2 * 0.75;
            const spikeLengthH = spikeLength * 2.08;
            const spikeLengthV = spikeLength * 0.54;
            const spikeWidth = Math.max(1.2, glowRadius * 0.13);
            const fadeStepsH = 18;
            const fadeStepsV = 38;
            // 4 main directions
            const directions = [
              [-1, 0],
              [1, 0],
              [0, -1],
              [0, 1],
            ];
            // Add extra directions if provided (for 8-spiked star)
            const allDirections = directions.concat(extraDirections);
            for (const [dx, dy] of allDirections) {
              const perp = [-dy, dx];
              // For diagonal spikes, treat as vertical for fade/length
              const isHorizontal = dx !== 0 && dy === 0;
              const isDiagonal = Math.abs(dx) === 1 && Math.abs(dy) === 1;
              const fadeSteps = isHorizontal ? fadeStepsH : fadeStepsV;
              for (let i = 0; i < fadeSteps; i++) {
                const t = i / fadeSteps;
                const alpha = isHorizontal
                  ? 0.06 * (1 - t) * (1 - t) // was 0.13
                  : 0.06 * Math.pow(1 - t, 2.7); // was 0.13
                if (alpha < 0.005) continue;
                const g = new PIXI.Graphics();
                g.beginFill(0xffffff, alpha);
                // For diagonal, start at center ball, same as vertical
                let startLen = coreRadius;
                if (!isHorizontal) {
                  startLen = coreRadius * 0.85;
                }
                // For diagonal, use vertical length
                let len = startLen + t * ((isHorizontal ? spikeLengthH : spikeLengthV) - startLen);
                let w = spikeWidth * (1 - t * 0.7);
                // For diagonal, compensate for aspect ratio in both x and y
                let x0 = dx * startLen + perp[0] * (-w / 2);
                let y0 = dy * startLen + perp[1] * (-w / 2);
                let x1 = dx * startLen + perp[0] * (w / 2);
                let y1 = dy * startLen + perp[1] * (w / 2);
                let x2 = dx * len + perp[0] * (w / 2);
                let y2 = dy * len + perp[1] * (w / 2);
                let x3 = dx * len + perp[0] * (-w / 2);
                let y3 = dy * len + perp[1] * (-w / 2);
                if (isHorizontal) {
                  x0 *= app.screen.height / app.screen.width;
                  x1 *= app.screen.height / app.screen.width;
                  x2 *= app.screen.height / app.screen.width;
                  x3 *= app.screen.height / app.screen.width;
                }
                if ((dy !== 0 && dx === 0) || isDiagonal) {
                  y0 *= app.screen.width / app.screen.height;
                  y1 *= app.screen.width / app.screen.height;
                  y2 *= app.screen.width / app.screen.height;
                  y3 *= app.screen.width / app.screen.height;
                }
                g.moveTo(x0, y0);
                g.lineTo(x1, y1);
                g.lineTo(x2, y2);
                g.lineTo(x3, y3);
                g.closePath();
                g.endFill();
                g.x = 0;
                g.y = 0;
                star.addChild(g);
              }
            }
            // Ring (less bright)
            const ring = new PIXI.Graphics();
            const ringInner = coreRadius * 0.33;
            const ringOuter = coreRadius * 0.33 + Math.max(1.0, glowRadius * 0.07);
            for (let r = ringOuter; r > ringInner; r -= 0.3) {
              const t = (r - ringInner) / (ringOuter - ringInner);
              const alpha = 0.13 * (1 - t) + 0.03 * t; // was 0.38/0.07
              ring.beginFill(0xffffff, alpha);
              ring.drawCircle(0, 0, r);
              ring.endFill();
            }
            ring.x = 0;
            ring.y = 0;
            star.addChild(ring);
            // Set pivot to center for rotation
            star.pivot.set(0, 0);
            return star;
          }

          // --- Place 4-5 randomly scattered 4- or 8-spiked stars in the sky ---
          const diag = Math.SQRT1_2; // 1/sqrt(2)
          const diagonalDirections = [
            [diag, diag],
            [-diag, diag],
            [diag, -diag],
            [-diag, -diag],
          ];
          const numStars = 4 + Math.floor(Math.random() * 2); // 4 or 5
          const starObjs = [];
          // Use same highest building Y as above
          const bgMaxHeight = 220;
          const bgBaseY = app.screen.height - 120;
          const highestBuildingY = bgBaseY - bgMaxHeight;
          for (let i = 0; i < numStars; i++) {
            // Randomly choose 4- or 8-spiked
            const isEight = Math.random() < 0.5;
            const star = isEight ? makeUnifiedStar(diagonalDirections) : makeUnifiedStar();
            // Random position in sky, always above highest building
            star.x = Math.random() * app.screen.width;
            const minY = 0;
            const maxY = highestBuildingY - 16;
            star.y = minY + Math.random() * (maxY - minY);
            // Random rotation
            star.rotation = Math.random() * Math.PI * 2;
            app.stage.addChildAt(star, 0);
            starObjs.push(star);
          }
          window.skyStars = starObjs;
        }
        drawBackdropCenterGlow();

        // --- CITYSCAPE BACKGROUND (faint, composited buildings) ---
        function drawCityscapeBackground() {
          const bgContainer = new PIXI.Container();
          // Parameters for background buildings
          const bgBuildingCount = 12;
          const bgMinWidth = 60, bgMaxWidth = 160;
          const bgMinHeight = 80, bgMaxHeight = 220;
          const bgBaseY = app.screen.height - 120;
          const bgColors = [0x1a1a2e, 0x23234a, 0x2a2a3a, 0x1a2a3a];
          const windowColors = [0x99e6ff, 0x66b3ff, 0xcccccc, 0x99ffe6];
          // Generate random background buildings
          let bgBuildings = [];
          for (let i = 0; i < bgBuildingCount; i++) {
            const w = bgMinWidth + Math.random() * (bgMaxWidth - bgMinWidth);
            const h = bgMinHeight + Math.random() * (bgMaxHeight - bgMinHeight);
            const x = Math.random() * (app.screen.width - w);
            const y = bgBaseY - h + Math.random() * 40;
            const color = bgColors[Math.floor(Math.random() * bgColors.length)];
            bgBuildings.push({ x, y, w, h, color, z: y + h });
          }
          // Sort by z (back to front)
          bgBuildings.sort((a, b) => a.z - b.z);
          // Draw each building with windows and details, no alpha stacking
          for (const b of bgBuildings) {
            const g = new PIXI.Graphics();
            // Building body (no alpha stacking, faint color)
            g.beginFill(b.color, 1.0);
            g.drawRect(0, 0, b.w, b.h);
            g.endFill();
            // Windows: grid, faint, some random lit
            const rows = Math.floor(b.h / 18);
            const cols = Math.floor(b.w / 16);
            for (let row = 0; row < rows; row++) {
              for (let col = 0; col < cols; col++) {
                if (Math.random() < 0.6) continue; // Only some windows lit
                const wx = 6 + col * ((b.w - 12) / cols);
                const wy = 8 + row * ((b.h - 16) / rows);
                const ww = Math.max(6, (b.w - 12) / cols - 4);
                const wh = Math.max(8, (b.h - 16) / rows - 4);
                g.beginFill(windowColors[Math.floor(Math.random() * windowColors.length)], 0.22 + Math.random() * 0.18);
                g.drawRect(wx, wy, ww, wh);
                g.endFill();
              }
            }
            // Rooftop details: faint antenna
            if (Math.random() < 0.5) {
              g.lineStyle(2, 0x99e6ff, 0.13);
              g.moveTo(b.w * (0.2 + 0.6 * Math.random()), 0);
              g.lineTo(b.w * (0.2 + 0.6 * Math.random()), -12 - Math.random() * 18);
            }
            g.x = b.x;
            g.y = b.y;
            bgContainer.addChild(g);
          }
          // Composite into a render texture
          const rt = PIXI.RenderTexture.create({ width: app.screen.width, height: app.screen.height });
          app.renderer.render(bgContainer, { renderTexture: rt });
          const bgSprite = new PIXI.Sprite(rt);
          bgSprite.alpha = 0.32;
          app.stage.addChildAt(bgSprite, 0);
        }
        drawCityscapeBackground();

        // --- MULTIPLE BUILDINGS AND BUNKER SETUP ---
        const buildingPieces = [];
        const explosionParticles = [];
        // Track active growing player explosions
        const activePlayerExplosions = [];
        const rockets = [];

        // Building and bunker dimensions
        const buildingWidth = 50;
        const buildingHeight = 75;
        const pieceWidth = buildingWidth / 4;
        const pieceHeight = buildingHeight / 4;
        const bunkerWidth = buildingWidth * 2;
        const bunkerHeight = 38;
        const bottomY = app.screen.height;
        const centerX = app.screen.width / 2;

        // Calculate building positions
        const numBuildingsPerSide = 3;
        const totalBuildings = 6;
        const leftSpace = centerX - bunkerWidth / 2;
        const rightSpace = app.screen.width - (centerX + bunkerWidth / 2);
        const leftSpacing = leftSpace / (numBuildingsPerSide + 1);
        const rightSpacing = rightSpace / (numBuildingsPerSide + 1);

        // Store all building centers
        const buildingCenters = [];
        // Left side buildings
        for (let i = 1; i <= numBuildingsPerSide; i++) {
          buildingCenters.push(leftSpacing * i - buildingWidth / 2);
        }
        // Right side buildings
        for (let i = 1; i <= numBuildingsPerSide; i++) {
          buildingCenters.push(centerX + bunkerWidth / 2 + rightSpacing * i - buildingWidth / 2);
        }

        // Draw all buildings (each as 16 pieces, roof, antennas)
        function drawBuilding(centerX, bottomY) {
          const pieces = [];
          const pieceWidth = buildingWidth / 4;
          const pieceHeight = buildingHeight / 4;
          // Roof
          const roofHeight = 12;
          const roofWidth = buildingWidth + 10;
          const roofX = centerX - roofWidth / 2;
          const roofY = bottomY - buildingHeight - roofHeight + 2;
          // Left roof part
          const roofLeft = new PIXI.Graphics();
          roofLeft.beginFill(0x222244);
          roofLeft.lineStyle(2, 0x00ffff, 0.7);
          roofLeft.moveTo(0, roofHeight);
          roofLeft.lineTo(roofWidth * 0.18, 0);
          roofLeft.lineTo(roofWidth * 0.5, 0);
          roofLeft.lineTo(roofWidth * 0.5, roofHeight);
          roofLeft.lineTo(0, roofHeight);
          roofLeft.endFill();
          roofLeft.x = roofX;
          roofLeft.y = roofY;
          roofLeft.gridX = -1;
          roofLeft.gridY = -1;
          roofLeft.originalX = roofX + roofWidth * 0.25;
          roofLeft.originalY = roofY + roofHeight / 2;
          pieces.push(roofLeft);
          app.stage.addChild(roofLeft);
          // Right roof part
          const roofRight = new PIXI.Graphics();
          roofRight.beginFill(0x222244);
          roofRight.lineStyle(2, 0x00ffff, 0.7);
          roofRight.moveTo(roofWidth * 0.5, roofHeight);
          roofRight.lineTo(roofWidth * 0.5, 0);
          roofRight.lineTo(roofWidth * 0.82, 0);
          roofRight.lineTo(roofWidth, roofHeight);
          roofRight.lineTo(roofWidth * 0.5, roofHeight);
          roofRight.endFill();
          roofRight.x = roofX;
          roofRight.y = roofY;
          roofRight.gridX = -2;
          roofRight.gridY = -2;
          roofRight.originalX = roofX + roofWidth * 0.75;
          roofRight.originalY = roofY + roofHeight / 2;
          pieces.push(roofRight);
          app.stage.addChild(roofRight);
          // 16 grid pieces
          for (let row = 0; row < 4; row++) {
            for (let col = 0; col < 4; col++) {
              const piece = new PIXI.Graphics();
              const pieceX = centerX - buildingWidth / 2 + col * pieceWidth;
              const pieceY = bottomY - buildingHeight + row * pieceHeight;
              piece.x = pieceX;
              piece.y = pieceY;
              piece.beginFill(0x1a1a2e);
              piece.drawRect(0, 0, pieceWidth, pieceHeight);
              piece.endFill();
              piece.lineStyle(1, 0x00ffff);
              if (col === 0) { piece.moveTo(0, 0); piece.lineTo(0, pieceHeight); }
              if (col === 3) { piece.moveTo(pieceWidth, 0); piece.lineTo(pieceWidth, pieceHeight); }
              if (row === 0) { piece.moveTo(0, 0); piece.lineTo(pieceWidth, 0); }
              if (row === 3) { piece.moveTo(0, pieceHeight); piece.lineTo(pieceWidth, pieceHeight); }
              if (row === 1 || row === 2) { piece.moveTo(0, pieceHeight); piece.lineTo(pieceWidth, pieceHeight); }
              if (col === 1 || col === 2) { piece.moveTo(pieceWidth, 0); piece.lineTo(pieceWidth, pieceHeight); }
              piece.lineStyle(0);
              if ((row === 0 && (col === 1 || col === 2)) ||
                (row === 1 && (col === 1 || col === 2)) ||
                (row === 2 && (col === 1 || col === 2))) {
                piece.beginFill(0x00ccff);
                piece.alpha = 0.85;
                const windowMargin = 2;
                piece.drawRect(windowMargin, windowMargin, pieceWidth - windowMargin * 2, pieceHeight - windowMargin * 2);
                piece.endFill();
                piece.alpha = 1.0;
              }
              if (col === 0 && (row === 1 || row === 2)) {
                piece.beginFill(0x00ff88);
                piece.drawRect(-3, 0, 3, pieceHeight);
                piece.endFill();
              }
              if (col === 3 && (row === 1 || row === 2)) {
                piece.beginFill(0x00ff88);
                piece.drawRect(pieceWidth, 0, 3, pieceHeight);
                piece.endFill();
              }
              piece.gridX = col;
              piece.gridY = row;
              piece.originalX = pieceX + pieceWidth / 2;
              piece.originalY = pieceY + pieceHeight / 2;
              pieces.push(piece);
              app.stage.addChild(piece);
            }
          }
          // Antennas
          function createAntenna(x, y, height, color, tipColor) {
            const antenna = new PIXI.Graphics();
            antenna.lineStyle(3, color, 0.8);
            antenna.moveTo(0, 0);
            antenna.lineTo(0, -height);
            antenna.beginFill(tipColor);
            antenna.drawCircle(0, -height, 4);
            antenna.endFill();
            antenna.x = x;
            antenna.y = y;
            antenna.alpha = 0.85;
            antenna.originalX = x;
            antenna.originalY = y - height / 2;
            antenna.isAntenna = true;
            pieces.push(antenna);
            app.stage.addChild(antenna);
          }
          createAntenna(roofX + 8, roofY + 2, 28, 0x00ffff, 0x00ffff);
          createAntenna(roofX + roofWidth - 8, roofY + 2, 28, 0xff00ff, 0xff00ff);
          // Add all to global buildingPieces
          buildingPieces.push(...pieces);
        }

        // Draw all 6 buildings
        for (let i = 0; i < buildingCenters.length; i++) {
          drawBuilding(buildingCenters[i] + buildingWidth / 2, bottomY);
        }

        // Draw a satellite dish on the left pole of the bunker
        function drawDishOnLeftPole() {
          const dish = new PIXI.Graphics();
          // Dish geometry
          const radius = 24;
          const startAngle = Math.PI * 1.2;
          const endAngle = Math.PI * 1.8;
          dish.lineStyle(3, 0xcccccc, 1.0);
          dish.beginFill(0xdddddd, 0.85);
          dish.arc(0, 0, radius, startAngle, endAngle, false);
          // Draw the straight (hollow) side
          const sx = Math.cos(startAngle) * radius;
          const sy = Math.sin(startAngle) * radius;
          const ex = Math.cos(endAngle) * radius;
          const ey = Math.sin(endAngle) * radius;
          dish.lineTo(ex, ey);
          dish.lineStyle(0);
          dish.endFill();

          // Calculate flat side angle and rod length
          const flatAngle = Math.atan2(ey - sy, ex - sx);
          const rodLength = 20;
          const mx = (sx + ex) / 2;
          const my = (sy + ey) / 2;
          const rodWidth = 3;
          const rodAngle = flatAngle + Math.PI / 2;
          const rodStartX = mx;
          const rodStartY = my;
          const rodEndX = mx + Math.cos(rodAngle) * rodLength;
          const rodEndY = my + Math.sin(rodAngle) * rodLength;
          const perpX = Math.cos(rodAngle + Math.PI / 2) * (rodWidth / 2);
          const perpY = Math.sin(rodAngle + Math.PI / 2) * (rodWidth / 2);
          const p1x = rodStartX + perpX;
          const p1y = rodStartY + perpY;
          const p2x = rodStartX - perpX;
          const p2y = rodStartY - perpY;
          const p3x = rodEndX - perpX;
          const p3y = rodEndY - perpY;
          const p4x = rodEndX + perpX;
          const p4y = rodEndY + perpY;
          dish.beginFill(0xbbbbbb);
          dish.moveTo(p1x, p1y);
          dish.lineTo(p2x, p2y);
          dish.lineTo(p3x, p3y);
          dish.lineTo(p4x, p4y);
          dish.closePath();
          dish.endFill();

          // Red dot receiver with pulsating glow
          const receiverGlow = new PIXI.Graphics();
          const receiverDot = new PIXI.Graphics();
          const receiverRadius = 4;
          const glowBaseRadius = 9;
          const glowColor = 0xff2222;
          const dotColor = 0xff0000;
          receiverGlow.x = rodEndX;
          receiverGlow.y = rodEndY;
          receiverDot.x = rodEndX;
          receiverDot.y = rodEndY;
          receiverGlow.beginFill(glowColor, 0.4);
          receiverGlow.drawCircle(0, 0, glowBaseRadius);
          receiverGlow.endFill();
          receiverDot.beginFill(dotColor, 1.0);
          receiverDot.drawCircle(0, 0, receiverRadius);
          receiverDot.endFill();
          dish.addChild(receiverGlow);
          dish.addChild(receiverDot);

          let glowTicker = 0;
          app.ticker.add(() => {
            glowTicker += 0.04;
            const pulse = 0.5 + 0.5 * Math.sin(glowTicker);
            const glowAlpha = 0.3 + 0.4 * pulse;
            const glowRadius = glowBaseRadius + 5.5 * pulse;
            receiverGlow.clear();
            receiverGlow.beginFill(glowColor, glowAlpha);
            receiverGlow.drawCircle(0, 0, glowRadius);
            receiverGlow.endFill();
          });

          // --- Placement and rotation ---
          // Left pole top coordinates (same as bunker pole)
          const poleWidth = 4;
          const poleHeight = 38;
          const poleLeftX = centerX - bunkerWidth / 2 - 6 + poleWidth / 2;
          const poleLeftY = bottomY - bunkerHeight - 10 - poleHeight;


          // We want the flat side (with the rod) to point 45 degrees to the top left.
          // The flat side is from (sx,sy) to (ex,ey), midpoint (mx,my), and its outward normal is rodAngle.
          // So, set dish.rotation so that rodAngle (in local dish space) aligns with -45 degrees (top left).
          // rodAngle in local dish space is flatAngle + Math.PI/2, so:
          // dish.rotation = -Math.PI/4 - rodAngle = -Math.PI/4 - (flatAngle + Math.PI/2)
          // But Pixi rotates the whole dish, so to make the rod point -45deg, set:
          // To point the rod 45 degrees to the top left, use +Math.PI/4 (135deg, counterclockwise from x axis)
          const desiredRodAngle = -3 * Math.PI / 4; // 135deg (top left)
          const dishRotation = desiredRodAngle - rodAngle;
          dish.rotation = dishRotation;

          // Now, after rotation, the round side midpoint must connect to the top of the pole.
          // Compute the rotated position of the round side midpoint
          const roundMidAngle = (startAngle + endAngle) / 2;
          const roundMidX = Math.cos(roundMidAngle) * radius;
          const roundMidY = Math.sin(roundMidAngle) * radius;
          // Rotate this point by dishRotation
          const cosR = Math.cos(dishRotation);
          const sinR = Math.sin(dishRotation);
          const roundMidXr = roundMidX * cosR - roundMidY * sinR;
          const roundMidYr = roundMidX * sinR + roundMidY * cosR;
          // Place dish so that (dish.x + roundMidXr, dish.y + roundMidYr) = (poleLeftX, poleLeftY)
          dish.x = poleLeftX - roundMidXr;
          dish.y = poleLeftY - roundMidYr;

          app.stage.addChild(dish);
        }
        drawDishOnLeftPole();

        // Draw a satellite dish on the right pole of the bunker, mirrored
        function drawDishOnRightPole() {
          const dish = new PIXI.Graphics();
          // Use the same geometry as the left dish
          const radius = 24;
          const startAngle = Math.PI * 1.2;
          const endAngle = Math.PI * 1.8;
          dish.lineStyle(3, 0xcccccc, 1.0);
          dish.beginFill(0xdddddd, 0.85);
          dish.arc(0, 0, radius, startAngle, endAngle, false);
          // Draw the straight (hollow) side
          const sx = Math.cos(startAngle) * radius;
          const sy = Math.sin(startAngle) * radius;
          const ex = Math.cos(endAngle) * radius;
          const ey = Math.sin(endAngle) * radius;
          dish.lineTo(ex, ey);
          dish.lineStyle(0);
          dish.endFill();

          // Calculate flat side angle and rod length
          const flatAngle = Math.atan2(ey - sy, ex - sx);
          const rodLength = 20;
          const mx = (sx + ex) / 2;
          const my = (sy + ey) / 2;
          const rodWidth = 3;
          const rodAngle = flatAngle + Math.PI / 2;
          const rodStartX = mx;
          const rodStartY = my;
          const rodEndX = mx + Math.cos(rodAngle) * rodLength;
          const rodEndY = my + Math.sin(rodAngle) * rodLength;
          const perpX = Math.cos(rodAngle + Math.PI / 2) * (rodWidth / 2);
          const perpY = Math.sin(rodAngle + Math.PI / 2) * (rodWidth / 2);
          const p1x = rodStartX + perpX;
          const p1y = rodStartY + perpY;
          const p2x = rodStartX - perpX;
          const p2y = rodStartY - perpY;
          const p3x = rodEndX - perpX;
          const p3y = rodEndY - perpY;
          const p4x = rodEndX + perpX;
          const p4y = rodEndY + perpY;
          dish.beginFill(0xbbbbbb);
          dish.moveTo(p1x, p1y);
          dish.lineTo(p2x, p2y);
          dish.lineTo(p3x, p3y);
          dish.lineTo(p4x, p4y);
          dish.closePath();
          dish.endFill();

          // Red dot receiver with pulsating glow
          const receiverGlow = new PIXI.Graphics();
          const receiverDot = new PIXI.Graphics();
          const receiverRadius = 4;
          const glowBaseRadius = 9;
          const glowColor = 0xff2222;
          const dotColor = 0xff0000;
          receiverGlow.x = rodEndX;
          receiverGlow.y = rodEndY;
          receiverDot.x = rodEndX;
          receiverDot.y = rodEndY;
          receiverGlow.beginFill(glowColor, 0.4);
          receiverGlow.drawCircle(0, 0, glowBaseRadius);
          receiverGlow.endFill();
          receiverDot.beginFill(dotColor, 1.0);
          receiverDot.drawCircle(0, 0, receiverRadius);
          receiverDot.endFill();
          dish.addChild(receiverGlow);
          dish.addChild(receiverDot);

          let glowTicker = 0;
          app.ticker.add(() => {
            glowTicker += 0.04;
            const pulse = 0.5 + 0.5 * Math.sin(glowTicker);
            const glowAlpha = 0.3 + 0.4 * pulse;
            const glowRadius = glowBaseRadius + 5.5 * pulse;
            receiverGlow.clear();
            receiverGlow.beginFill(glowColor, glowAlpha);
            receiverGlow.drawCircle(0, 0, glowRadius);
            receiverGlow.endFill();
          });

          // --- Placement and rotation ---
          // Right pole top coordinates (same as bunker pole)
          const poleWidth = 4;
          const poleHeight = 38;
          const poleRightX = centerX + bunkerWidth / 2 + 6 - poleWidth / 2;
          const poleRightY = bottomY - bunkerHeight - 10 - poleHeight;

          // We want the flat side (with the rod) to point 45 degrees to the top right.
          // So, set dish.rotation so that rodAngle aligns with +45deg (top right)
          const desiredRodAngle = -Math.PI / 4; // -45deg (top right)
          const dishRotation = desiredRodAngle - rodAngle;
          dish.rotation = dishRotation;

          // Now, after rotation, the round side midpoint must connect to the top of the pole.
          const roundMidAngle = (startAngle + endAngle) / 2;
          const roundMidX = Math.cos(roundMidAngle) * radius;
          const roundMidY = Math.sin(roundMidAngle) * radius;
          const cosR = Math.cos(dishRotation);
          const sinR = Math.sin(dishRotation);
          const roundMidXr = roundMidX * cosR - roundMidY * sinR;
          const roundMidYr = roundMidX * sinR + roundMidY * cosR;
          dish.x = poleRightX - roundMidXr;
          dish.y = poleRightY - roundMidYr;

          app.stage.addChild(dish);
        }
        drawDishOnRightPole();

        // --- FRIENDLY ROCKET ICONS (visual indicator, step 1) ---
        // Container for rocket icons
        const rocketIconsContainer = new PIXI.Container();
        app.stage.addChild(rocketIconsContainer);

        // --- FRIENDLY ROCKET LIMIT LOGIC (step 2) ---
        const MAX_FRIENDLY_ROCKETS = 3;
        let availableFriendlyRockets = MAX_FRIENDLY_ROCKETS;
        // Each element: true = green (available), false = red (used)
        let rocketIconsState = [true, true, true];

        // Draw/update the 3 rocket icons (triangles)
        function drawRocketIcons(iconsState = rocketIconsState) {
          rocketIconsContainer.removeChildren();
          const iconCount = 3;
          const iconSpacing = 20; // closer together
          const iconWidth = 12;   // smaller width
          const iconHeight = 18;  // smaller height
          const y = bottomY - bunkerHeight - 44; // move up by 10px
          const totalWidth = (iconCount - 1) * iconSpacing;
          const startX = centerX - totalWidth / 2;
          for (let i = 0; i < iconCount; i++) {
            const icon = new PIXI.Graphics();
            const color = iconsState[i] ? 0x00ff44 : 0xff2222;
            // Draw missile body (rectangle)
            const bodyWidth = 5;
            const bodyHeight = 12;
            // If unavailable (red), body is red; if available, body is gray
            const bodyColor = iconsState[i] ? 0xcccccc : 0xff2222;
            icon.beginFill(bodyColor);
            icon.drawRect((iconWidth - bodyWidth) / 2, -bodyHeight, bodyWidth, bodyHeight);
            icon.endFill();

            // Draw nose cone (triangle)
            icon.beginFill(color); // green or red nose
            icon.moveTo(iconWidth / 2, -iconHeight); // tip
            icon.lineTo((iconWidth / 2) - 4, -bodyHeight);
            icon.lineTo((iconWidth / 2) + 4, -bodyHeight);
            icon.lineTo(iconWidth / 2, -iconHeight);
            icon.endFill();

            // Draw fins (two small triangles)
            icon.beginFill(0x888888); // darker gray for fins
            // Left fin
            icon.moveTo((iconWidth / 2) - 2, 0);
            icon.lineTo((iconWidth / 2) - 7, 4);
            icon.lineTo((iconWidth / 2) - 2, -2);
            icon.lineTo((iconWidth / 2) - 2, 0);
            // Right fin
            icon.moveTo((iconWidth / 2) + 2, 0);
            icon.lineTo((iconWidth / 2) + 7, 4);
            icon.lineTo((iconWidth / 2) + 2, -2);
            icon.lineTo((iconWidth / 2) + 2, 0);
            icon.endFill();

            // Optional: Draw a small exhaust circle at the base
            icon.beginFill(0xffcc00, 0.7); // yellow-orange exhaust
            icon.drawCircle(iconWidth / 2, 2, 1.5);
            icon.endFill();

            icon.x = startX + i * iconSpacing - iconWidth / 2;
            icon.y = y;
            rocketIconsContainer.addChild(icon);
          }
        }
        // Draw initial icons (all green)
        drawRocketIcons();

        // Per-rocket cooldown timers: when a rocket is fired, start a 2s timer to restore it
        let rocketCooldownTimers = [null, null, null];

        function startRocketCooldown(index) {
          if (rocketCooldownTimers[index]) return; // Already running
          rocketCooldownTimers[index] = setTimeout(() => {
            // Restore this rocket slot only
            if (!rocketIconsState[index]) {
              rocketIconsState[index] = true;
              availableFriendlyRockets++;
              drawRocketIcons();
            }
            clearTimeout(rocketCooldownTimers[index]);
            rocketCooldownTimers[index] = null;
          }, 2000);
        }

        // Draw the central bunker as a military structure
        function drawBunker(centerX, bottomY) {
          // (Searchlight beam logic moved to animation loop)
          // --- TOP TRAPEZOID STRUCTURE ---
          // Smaller trapezoid dimensions
          const trapezoidWidth = bunkerWidth * 0.45;
          const trapezoidHeight = 22;
          const trapezoidSlope = 18; // match bunker base slope
          // Place directly on top of the bunker roof
          const roofTopY = bottomY - bunkerHeight - 10; // roof top (roof is 14px tall)
          const trapezoidBaseY = roofTopY;
          const trapezoidTopY = roofTopY - trapezoidHeight;
          const trapezoidLeftX = centerX - trapezoidWidth / 2;
          const trapezoidRightX = centerX + trapezoidWidth / 2;
          // Outer border
          const topTrapezoid = new PIXI.Graphics();
          topTrapezoid.lineStyle(6, 0x888c99, 1.0);
          topTrapezoid.beginFill(0x33363a); // dark gray inner color
          topTrapezoid.moveTo(trapezoidLeftX - trapezoidSlope, trapezoidBaseY);
          topTrapezoid.lineTo(trapezoidRightX + trapezoidSlope, trapezoidBaseY);
          topTrapezoid.lineTo(trapezoidRightX, trapezoidTopY);
          topTrapezoid.lineTo(trapezoidLeftX, trapezoidTopY);
          topTrapezoid.lineTo(trapezoidLeftX - trapezoidSlope, trapezoidBaseY);
          topTrapezoid.endFill();
          app.stage.addChild(topTrapezoid);

          // Two red windows, vertically centered in the trapezoid
          const windowWidth = trapezoidWidth * 0.18;
          const windowHeight = 8;
          const windowY = trapezoidTopY + (trapezoidHeight - windowHeight) / 2;
          const windowSpacing = trapezoidWidth * 0.32;
          for (let i = 0; i < 2; i++) {
            const wx = centerX - windowSpacing / 2 + i * windowSpacing;
            const window = new PIXI.Graphics();
            window.beginFill(0xff2222);
            window.lineStyle(2, 0xff4444, 0.7);
            window.drawRoundedRect(wx - windowWidth / 2, windowY, windowWidth, windowHeight, 3);
            window.endFill();
            app.stage.addChild(window);
          }
          const bunker = new PIXI.Graphics();
          // Main body: thick, angular, concrete look
          bunker.beginFill(0x33363a);
          bunker.lineStyle(6, 0x888c99, 1.0);
          // Trapezoidal base for sloped armor
          const baseY = bottomY;
          const topY = bottomY - bunkerHeight;
          const slope = 18;
          bunker.moveTo(centerX - bunkerWidth / 2 - slope, baseY);
          bunker.lineTo(centerX + bunkerWidth / 2 + slope, baseY);
          bunker.lineTo(centerX + bunkerWidth / 2, topY);
          bunker.lineTo(centerX - bunkerWidth / 2, topY);
          bunker.lineTo(centerX - bunkerWidth / 2 - slope, baseY);
          bunker.endFill();

          // Flat reinforced roof
          bunker.beginFill(0x44474c);
          bunker.lineStyle(0);
          bunker.drawRect(centerX - bunkerWidth / 2 - 6, topY - 10, bunkerWidth + 12, 14);
          bunker.endFill();

          // Firing slits (narrow, dark, evenly spaced)
          const slitCount = 5;
          const slitWidth = bunkerWidth * 0.10;
          const slitHeight = 7;
          const slitY = topY + 18;
          for (let i = 0; i < slitCount; i++) {
            const slitX = centerX - bunkerWidth / 2 + (bunkerWidth / (slitCount + 1)) * (i + 1) - slitWidth / 2;
            // Glowing blue window
            bunker.beginFill(0x00ccff);
            bunker.lineStyle(2, 0x00ffff, 0.7);
            bunker.drawRoundedRect(slitX, slitY, slitWidth, slitHeight, 3);
            bunker.endFill();
            bunker.lineStyle(0);
          }

          // Reinforcement lines (horizontal)
          bunker.lineStyle(2, 0x888c99, 0.5);
          for (let i = 1; i <= 2; i++) {
            const y = baseY - (bunkerHeight * i) / 3;
            bunker.moveTo(centerX - bunkerWidth / 2 - slope / 2, y);
            bunker.lineTo(centerX + bunkerWidth / 2 + slope / 2, y);
          }

          // Add a thick base border for extra strength
          bunker.lineStyle(8, 0x888c99, 0.8);
          bunker.moveTo(centerX - bunkerWidth / 2 - slope, baseY);
          bunker.lineTo(centerX + bunkerWidth / 2 + slope, baseY);

          app.stage.addChild(bunker);

          // --- SATELLITE DISH POLES ---
          // Left pole
          const poleLeft = new PIXI.Graphics();
          const poleWidth = 4;
          const poleHeight = 38;
          const poleColor = 0x44474c; // same as bunker roof
          // Place at left edge of roof
          const poleLeftX = centerX - bunkerWidth / 2 - 6 + poleWidth / 2;
          const poleLeftY = topY - 10;
          poleLeft.beginFill(poleColor);
          poleLeft.drawRect(-poleWidth / 2, -poleHeight, poleWidth, poleHeight);
          poleLeft.endFill();
          poleLeft.x = poleLeftX;
          poleLeft.y = poleLeftY;
          app.stage.addChild(poleLeft);

          // Right pole
          const poleRight = new PIXI.Graphics();
          const poleRightX = centerX + bunkerWidth / 2 + 6 - poleWidth / 2;
          const poleRightY = topY - 10;
          poleRight.beginFill(poleColor);
          poleRight.drawRect(-poleWidth / 2, -poleHeight, poleWidth, poleHeight);
          poleRight.endFill();
          poleRight.x = poleRightX;
          poleRight.y = poleRightY;
          app.stage.addChild(poleRight);
        }
        drawBunker(centerX, bottomY);

        // --- SEARCHLIGHT BEAM: Draw and animate in main loop ---
        // Create a container for the searchlight so we can update it each frame
        const searchlightContainer = new PIXI.Container();
        app.stage.addChildAt(searchlightContainer, 0); // behind bunker

        // Store state for animation (angle, etc.) and visibility
        window._searchlightState = {
          angle: 0, // straight up
          visible: true // searchlight is on by default
        };

        function drawSearchlight() {
          // Remove previous beam
          searchlightContainer.removeChildren();
          // Only draw if visible
          if (!window._searchlightState.visible) return;
          // Parameters for searchlight
          const beamBaseY = bottomY - bunkerHeight - 10; // roof top
          const beamBaseX = centerX;
          const beamBaseWidth = 4;
          const beamTopWidth = 120;
          const beamAlpha = 0.13;
          // Animate angle (in radians)
          const angle = window._searchlightState.angle || 0;
          // Extend the beam much further into the sky (2.5x the screen height)
          const farSkyY = beamBaseY - app.screen.height * 2.5;
          // Base points (at bunker roof)
          const baseLeft = rotatePoint(
            beamBaseX - beamBaseWidth / 2,
            beamBaseY,
            beamBaseX,
            beamBaseY,
            angle
          );
          const baseRight = rotatePoint(
            beamBaseX + beamBaseWidth / 2,
            beamBaseY,
            beamBaseX,
            beamBaseY,
            angle
          );
          // Top points (far into the sky)
          const topLeft = rotatePoint(
            beamBaseX - beamTopWidth / 2,
            farSkyY,
            beamBaseX,
            beamBaseY,
            angle
          );
          const topRight = rotatePoint(
            beamBaseX + beamTopWidth / 2,
            farSkyY,
            beamBaseX,
            beamBaseY,
            angle
          );
          // Draw the beam as a single polygon (trapezoid) with constant faint alpha
          const searchlight = new PIXI.Graphics();
          searchlight.beginFill(0xffffcc, beamAlpha);
          searchlight.moveTo(baseLeft.x, baseLeft.y);
          searchlight.lineTo(baseRight.x, baseRight.y);
          searchlight.lineTo(topRight.x, topRight.y);
          searchlight.lineTo(topLeft.x, topLeft.y);
          searchlight.closePath();
          searchlight.endFill();
          searchlightContainer.addChild(searchlight);
        }

        // Helper to rotate a point (x, y) around (cx, cy) by angle (radians)
        function rotatePoint(x, y, cx, cy, angle) {
          const dx = x - cx;
          const dy = y - cy;
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          return {
            x: cx + dx * cos - dy * sin,
            y: cy + dx * sin + dy * cos
          };
        }

        // Draw once initially
        drawSearchlight();

        // Update searchlight in main animation loop
        let sweepDir = 1;
        app.ticker.add(() => {
          // Animate angle: sweep left/right between -0.52 and +0.52 radians (about -30 to +30 deg)
          const state = window._searchlightState;
          if (!state.angle) state.angle = 0;
          const sweepSpeed = 0.0035;
          state.angle += sweepSpeed * sweepDir;
          const maxAngle = 0.52;
          if (state.angle > maxAngle) {
            state.angle = maxAngle;
            sweepDir = -1;
          } else if (state.angle < -maxAngle) {
            state.angle = -maxAngle;
            sweepDir = 1;
          }
          drawSearchlight();
        });

        // --- ROUND SYSTEM ---
        let roundNumber = 1;
        let roundActive = false;
        let roundTimer = 0;
        let roundDuration = 10 * 60; // 10 seconds at 60fps (testing)
        let roundPause = true;
        let roundFinishedText = null;
        // Scoring and round stats
        let rocketsDestroyed = 0;
        let buildingsDestroyed = 0;
        let enemyRocketInterval = 90; // frames between enemy rockets (1.5s at 60fps, can scale with round)
        let enemyRocketFrameCounter = 0;

        // --- PLAYER SCORE AND ROUND TIMER UI ---
        let playerScore = 0;
        // Score display (smaller, green, closer to top)
        const scoreDiv = document.createElement('div');
        scoreDiv.textContent = `Score: ${playerScore}`;
        scoreDiv.style.position = 'fixed';
        scoreDiv.style.top = '6px';
        scoreDiv.style.left = '50%';
        scoreDiv.style.transform = 'translateX(-50%)';
        scoreDiv.style.zIndex = '1500';
        scoreDiv.style.fontSize = '1.2rem';
        scoreDiv.style.fontWeight = 'bold';
        scoreDiv.style.color = '#00ff44';
        scoreDiv.style.textShadow = '0 1px 4px #000, 0 0px 2px #00ccff';
        scoreDiv.style.letterSpacing = '0.04em';
        scoreDiv.style.userSelect = 'none';
        document.body.appendChild(scoreDiv);

        // Round seconds-left display (smaller, green, closer to top left)
        const roundTimeDiv = document.createElement('div');
        roundTimeDiv.textContent = '';
        roundTimeDiv.style.position = 'fixed';
        roundTimeDiv.style.top = '6px';
        roundTimeDiv.style.left = '10px';
        roundTimeDiv.style.zIndex = '1500';
        roundTimeDiv.style.fontSize = '1.1rem';
        roundTimeDiv.style.fontWeight = 'bold';
        roundTimeDiv.style.color = '#00ff44';
        roundTimeDiv.style.textShadow = '0 1px 4px #000, 0 0px 2px #00ccff';
        roundTimeDiv.style.letterSpacing = '0.04em';
        roundTimeDiv.style.userSelect = 'none';
        document.body.appendChild(roundTimeDiv);

        // Fancy Start Round button
        const startRoundBtn = document.createElement('button');
        startRoundBtn.textContent = 'Start round 1';
        startRoundBtn.style.position = 'fixed';
        startRoundBtn.style.top = '50%';
        startRoundBtn.style.left = '50%';
        startRoundBtn.style.transform = 'translate(-50%, -50%)';
        startRoundBtn.style.zIndex = '2000';
        startRoundBtn.style.padding = '28px 64px';
        startRoundBtn.style.background = 'linear-gradient(90deg, #00ccff 0%, #ff00cc 100%)';
        startRoundBtn.style.color = '#fff';
        startRoundBtn.style.border = '4px solid #fff';
        startRoundBtn.style.borderRadius = '18px';
        startRoundBtn.style.fontSize = '2.2rem';
        startRoundBtn.style.cursor = 'pointer';
        startRoundBtn.style.boxShadow = '0 8px 32px rgba(0,0,0,0.28)';
        startRoundBtn.style.userSelect = 'none';
        startRoundBtn.style.fontWeight = 'bold';
        startRoundBtn.style.letterSpacing = '0.04em';
        startRoundBtn.style.display = 'block';
        startRoundBtn.style.transition = 'background 0.3s';
        startRoundBtn.addEventListener('mouseenter', () => {
          startRoundBtn.style.background = 'linear-gradient(90deg, #ff00cc 0%, #00ccff 100%)';
        });
        startRoundBtn.addEventListener('mouseleave', () => {
          startRoundBtn.style.background = 'linear-gradient(90deg, #00ccff 0%, #ff00cc 100%)';
        });
        document.body.appendChild(startRoundBtn);

        // Colorful round finished text with summary
        function showRoundFinishedText(round) {
          if (roundFinishedText) {
            roundFinishedText.remove();
            roundFinishedText = null;
          }
          const div = document.createElement('div');
          div.innerHTML = `Round ${round} finished<br><span style="font-size:1.3rem;">Rockets destroyed: ${rocketsDestroyed}<br>Buildings destroyed: ${buildingsDestroyed}</span>`;
          div.style.position = 'fixed';
          div.style.top = '50%';
          div.style.left = '50%';
          div.style.transform = 'translate(-50%, -50%)';
          div.style.zIndex = '2000';
          div.style.padding = '32px 80px';
          div.style.background = 'linear-gradient(90deg, #ffef00 0%, #ff00cc 100%)';
          div.style.color = '#222';
          div.style.border = '6px solid #fff';
          div.style.borderRadius = '22px';
          div.style.fontSize = '2.5rem';
          div.style.fontWeight = 'bold';
          div.style.boxShadow = '0 8px 32px rgba(0,0,0,0.28)';
          div.style.userSelect = 'none';
          div.style.letterSpacing = '0.04em';
          div.style.textAlign = 'center';
          div.style.display = 'block';
          document.body.appendChild(div);
          roundFinishedText = div;
        }

        function hideRoundFinishedText() {
          if (roundFinishedText) {
            roundFinishedText.remove();
            roundFinishedText = null;
          }
        }

        // Start round handler
        function startRound() {
          roundPause = false;
          roundActive = true;
          roundTimer = 0;
          rocketsDestroyed = 0;
          buildingsDestroyed = 0;
          hideRoundFinishedText();
          startRoundBtn.style.display = 'none';
        }

        startRoundBtn.addEventListener('click', () => {
          startRound();
        });

        // At game start, show the button
        startRoundBtn.textContent = `Start round ${roundNumber}`;
        startRoundBtn.style.display = 'block';

        // --- UI: Add a button to toggle searchlight (logic preserved, but button hidden for now) ---
        const toggleBtn = document.createElement('button');
        toggleBtn.textContent = 'Toggle Searchlight';
        // ...existing code...
        toggleBtn.style.display = 'none'; // Hide for now
        document.body.appendChild(toggleBtn);
        toggleBtn.addEventListener('click', () => {
          window._searchlightState.visible = !window._searchlightState.visible;
          drawSearchlight();
        });

        // --- Searchlight toggle every 600-900 frames, independent of round ---
        let searchlightFrameCounter = 0;
        let searchlightToggleInterval = 600 + Math.floor(Math.random() * 301); // 600-900 frames
        app.ticker.add(() => {
          // Round system logic
          if (roundActive) {
            roundTimer++;
            // Update round seconds-left UI
            const secondsLeft = Math.max(0, Math.ceil((roundDuration - roundTimer) / 60));
            roundTimeDiv.textContent = `Round: ${secondsLeft}s`;
            if (roundTimer >= roundDuration) {
              // On round end, treat all flying enemy rockets as if hit by a friendly rocket (for scoring and explosion logic)
              // Simultaneously destroy all flying enemy rockets at round end
              rockets.filter(r => !r.isPlayerRocket).forEach(rocket => {
                destroyEnemyRocketByPlayer(rocket, false); // false = not by player, do not increment score/stats
              });
              roundActive = false;
              roundPause = true;
              roundNumber++;
              // Wait until all enemy rocket explosion particles are gone before showing round finished dialog
              function waitForEnemyExplosionsAndShowDialog() {
                if (explosionParticles.length === 0) {
                  showRoundFinishedText(roundNumber - 1);
                  // After 2s, show the start button for next round
                  setTimeout(() => {
                    startRoundBtn.textContent = `Start round ${roundNumber}`;
                    startRoundBtn.style.display = 'block';
                    hideRoundFinishedText();
                  }, 2000);
                } else {
                  requestAnimationFrame(waitForEnemyExplosionsAndShowDialog);
                }
              }
              waitForEnemyExplosionsAndShowDialog();
            }
          } else {
            // Hide timer if not in round
            roundTimeDiv.textContent = '';
          }
          // Pause all game logic if not in round (except searchlight toggle)
          if (!roundActive) return;
        });

        // Separate ticker for searchlight toggle (always runs)
        app.ticker.add(() => {
          searchlightFrameCounter = (Number(searchlightFrameCounter) || 0) + 1;
          if (searchlightFrameCounter >= searchlightToggleInterval) {
            searchlightFrameCounter = 0;
            window._searchlightState.visible = !window._searchlightState.visible;
            drawSearchlight();
            searchlightToggleInterval = 600 + Math.floor(Math.random() * 301); // 600-900 frames
          }
        });
        
        // Create a rocket function
        function createRocket() {
          const rocket = new PIXI.Graphics();
          // Draw rocket as small white circle
          rocket.beginFill(0xFF2222); // Red for enemy rocket
          rocket.drawCircle(0, 0, 3); // 3-pixel radius white circle
          rocket.endFill();
          // Position at middle top of screen
          rocket.x = centerX;
          rocket.y = 0;
          // Set velocity - moving downward toward building at half speed (2.5 px/frame)
          rocket.vx = 0;
          rocket.vy = 1.5;
          // Trail system
          rocket.trail = []; // Array to store trail particles
          rocket.maxTrailLength = 25;
          rockets.push(rocket);
          app.stage.addChild(rocket);
        }
        
        // Add keyboard handler to create rockets and test enemy explosion
        window.addEventListener('keydown', (event) => {
          if (event.code === 'Space') {
            createRocket();
          }
        });

        // Add click handler to launch a green rocket from bunker roof towards mouse click
        app.canvas.addEventListener('click', (event) => {
          if (event.button === 0) {
            // Friendly rocket limit logic
            if (availableFriendlyRockets <= 0) {
              // Optionally: play a sound or flash icons
              return;
            }
            // Get mouse position relative to canvas
            const rect = app.canvas.getBoundingClientRect();
            const mouseX = (event.clientX - rect.left) * (app.screen.width / rect.width);
            const mouseY = (event.clientY - rect.top) * (app.screen.height / rect.height);
            // Bunker roof center
            const bunkerTopX = centerX;
            const bunkerTopY = bottomY - bunkerHeight - 10;
            // Calculate velocity to aim at mouse
            const dx = mouseX - bunkerTopX;
            const dy = mouseY - bunkerTopY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const speed = 6;
            const vx = dx / dist * speed;
            const vy = dy / dist * speed;
            // Create green rocket
            const rocket = new PIXI.Graphics();
            rocket.beginFill(0x00ff44);
            rocket.drawCircle(0, 0, 3);
            rocket.endFill();
            rocket.x = bunkerTopX;
            rocket.y = bunkerTopY;
            rocket.vx = vx;
            rocket.vy = vy;
            rocket.trail = [];
            rocket.maxTrailLength = 25;
            rocket.isPlayerRocket = true;
            rocket.targetX = mouseX;
            rocket.targetY = mouseY;
            rockets.push(rocket);
            app.stage.addChild(rocket);
            // Update rocket icon state: leftmost green turns red and start cooldown for that slot
            for (let i = 0; i < MAX_FRIENDLY_ROCKETS; i++) {
              if (rocketIconsState[i]) {
                rocketIconsState[i] = false;
                availableFriendlyRockets--;
                drawRocketIcons();
                startRocketCooldown(i);
                break;
              }
            }
          }
        });

        // Add right-click handler to launch a targeted rocket (DISABLED, keep code for future testing)
        // app.canvas.addEventListener('contextmenu', (event) => {
        //   event.preventDefault(); // Prevent context menu
        //   // Pick a random building
        //   const buildingIdx = Math.floor(Math.random() * buildingCenters.length);
        //   const buildingCenterX = buildingCenters[buildingIdx] + buildingWidth / 2;
        //   const buildingTopY = bottomY - buildingHeight;
        //   // Spawn rocket at random X at top
        //   const rocketStartX = Math.random() * app.screen.width;
        //   const rocketStartY = 0;
        //   // Calculate velocity to aim at building
        //   const dx = buildingCenterX - rocketStartX;
        //   const dy = buildingTopY - rocketStartY;
        //   const dist = Math.sqrt(dx * dx + dy * dy);
        //   const speed = 1.5; // Slower enemy rocket speed
        //   const vx = dx / dist * speed;
        //   const vy = dy / dist * speed;
        //   // Create rocket
        //   const rocket = new PIXI.Graphics();
        //   rocket.beginFill(0xFF2222); // Red for enemy rocket
        //   rocket.drawCircle(0, 0, 3);
        //   rocket.endFill();
        //   rocket.x = rocketStartX;
        //   rocket.y = rocketStartY;
        //   rocket.vx = vx;
        //   rocket.vy = vy;
        //   rocket.trail = [];
        //   rocket.maxTrailLength = 25;
        //   rocket.targetBuildingIdx = buildingIdx;
        //   rocket.targetX = buildingCenterX;
        //   rocket.targetY = buildingTopY;
        //   rockets.push(rocket);
        //   app.stage.addChild(rocket);
        // });
        // --- Automatic enemy rocket firing during active round ---
        app.ticker.add(() => {
          if (!roundActive) return;
          enemyRocketFrameCounter++;
          if (enemyRocketFrameCounter >= enemyRocketInterval) {
            enemyRocketFrameCounter = 0;
            // Pick a random building
            const buildingIdx = Math.floor(Math.random() * buildingCenters.length);
            const buildingCenterX = buildingCenters[buildingIdx] + buildingWidth / 2;
            const buildingTopY = bottomY - buildingHeight;
            // Spawn rocket at random X at top
            const rocketStartX = Math.random() * app.screen.width;
            const rocketStartY = 0;
            // Calculate velocity to aim at building
            const dx = buildingCenterX - rocketStartX;
            const dy = buildingTopY - rocketStartY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const speed = 1.5; // Slower enemy rocket speed
            const vx = dx / dist * speed;
            const vy = dy / dist * speed;
            // Create rocket
            const rocket = new PIXI.Graphics();
            rocket.beginFill(0xFF2222); // Red for enemy rocket
            rocket.drawCircle(0, 0, 3);
            rocket.endFill();
            rocket.x = rocketStartX;
            rocket.y = rocketStartY;
            rocket.vx = vx;
            rocket.vy = vy;
            rocket.trail = [];
            rocket.maxTrailLength = 25;
            rocket.targetBuildingIdx = buildingIdx;
            rocket.targetX = buildingCenterX;
            rocket.targetY = buildingTopY;
            rockets.push(rocket);
            app.stage.addChild(rocket);
          }
        });

        // Explosion function (no-op, left for compatibility)
        function explodeBuilding() {
          // No action; buildings only explode when hit by a rocket
        }

        // Explosion function for a specific building
        function explodeBuildingAt(buildingIdx) {
          console.log('Exploding building at index:', buildingIdx);
          buildingsDestroyed++;
          playerScore -= 500;
          scoreDiv.textContent = `Score: ${playerScore}`;
          // Find all pieces belonging to this building (by gridX/gridY and position)
          buildingPieces.forEach((piece) => {
            if (
              piece.originalX >= buildingCenters[buildingIdx] &&
              piece.originalX < buildingCenters[buildingIdx] + buildingWidth
            ) {
              // Explode this piece
              piece.vx = (Math.random() - 0.5) * 3.0;
              piece.vy = -(4.0 + Math.random() * 3.2);
              piece.rotationSpeed = (Math.random() - 0.5) * 0.1;
              piece.exploding = true;
              piece.landed = false;
              piece.bounced = false;
            }
          });
          // Center explosion at building base
          const x = buildingCenters[buildingIdx] + buildingWidth / 2;
          const y = bottomY;
          createExplosionParticles(x, y);
        }
        // --- Add scoring for enemy rocket destruction by player ---

        // Unified function: destroy enemy rocket as if hit by friendly rocket explosion
        function destroyEnemyRocketByPlayer(rocket, byPlayer = true) {
          createRedBurstExplosion(rocket.x, rocket.y);
          app.stage.removeChild(rocket);
          if (rocket.trail) rocket.trail.forEach(trail => app.stage.removeChild(trail));
          const idx = rockets.indexOf(rocket);
          if (idx !== -1) rockets.splice(idx, 1);
          if (byPlayer) {
            rocketsDestroyed++;
            playerScore += 100;
            scoreDiv.textContent = `Score: ${playerScore}`;
          }
        }

        // Generic explosion function that can be called from anywhere
        function explodeAtPosition(x, y) {
          // Create explosion particles at specified position
          createExplosionParticles(x, y);
          
          buildingPieces.forEach((piece, index) => {
            // Random horizontal speed anywhere from -1.5 to +1.5 (including zero for straight up)
            piece.vx = (Math.random() - 0.5) * 3.0; // -1.5 to +1.5 pixels per frame
            
            // Random slow vertical speed (upward) - halved max velocity with offset
            piece.vy = -(4.0 + Math.random() * 3.2); // -4.0 to -7.2 pixels per frame (negative = upward)
            
            // Random rotation speed
            piece.rotationSpeed = (Math.random() - 0.5) * 0.1; // -0.05 to 0.05 radians per frame
            
            // Mark as exploding
            piece.exploding = true;
            piece.landed = false;
            piece.bounced = false; // Track if piece has bounced yet
          });
        }

        // Create explosion particles for building destruction (restored original counts)
        function createExplosionParticles(explosionCenterX = centerX, explosionCenterY = bottomY) {
          // Create fire/spark particles (original: 100)
          for (let i = 0; i < 100; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 9;
            const size = 1 + Math.random() * 6;
            const colors = [0xFF4500, 0xFF6600, 0xFF8C00, 0xFFD700, 0xFFFFFF];
            const color = colors[Math.floor(Math.random() * colors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX;
            particle.y = explosionCenterY;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = -Math.random() * 10;
            particle.life = 1.0;
            particle.maxLife = 60 + Math.random() * 60;
            particle.type = 'fire';
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
          // Create sparkle particles (original: 100)
          for (let i = 0; i < 100; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 4;
            const size = 1 + Math.random() * 4;
            const sparkleColors = [0x00FFFF, 0xFFFFFF, 0xFFD700, 0xFF69B4];
            const color = sparkleColors[Math.floor(Math.random() * sparkleColors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX;
            particle.y = explosionCenterY;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = -Math.random() * 5;
            particle.life = 1.0;
            particle.maxLife = 40 + Math.random() * 40;
            particle.type = 'sparkle';
            particle.twinkle = Math.random() * Math.PI * 2;
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
          // Create yellow spark cloud (original: 400)
          for (let i = 0; i < 400; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.5 + Math.random() * 3.0;
            const size = 1 + Math.random() * 3;
            const yellowColors = [0xFFFF00, 0xFFD700, 0xFFA500, 0xFFFF99, 0xFFE135];
            const color = yellowColors[Math.floor(Math.random() * yellowColors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX + (Math.random() - 0.5) * 20;
            particle.y = explosionCenterY + (Math.random() - 0.5) * 20;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed - 1;
            particle.life = 1.0;
            particle.maxLife = 120 + Math.random() * 80;
            particle.type = 'yellowCloud';
            particle.flickerPhase = Math.random() * Math.PI * 2;
            particle.expansion = 0;
            particle.gravity = 0.01 + Math.random() * 0.02;
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
        }

        // Create explosion particles for enemy rocket explosions (reduced counts)
        function createEnemyRocketExplosionParticles(explosionCenterX, explosionCenterY) {
          // Create fire/spark particles (360)
          for (let i = 0; i < 360; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 9;
            const size = 1 + Math.random() * 6;
            const colors = [0xFF4500, 0xFF6600, 0xFF8C00, 0xFFD700, 0xFFFFFF];
            const color = colors[Math.floor(Math.random() * colors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX;
            particle.y = explosionCenterY;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = -Math.random() * 10;
            particle.life = 1.0;
            particle.maxLife = 60 + Math.random() * 60;
            particle.type = 'fire';
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
          // Create sparkle particles (160)
          for (let i = 0; i < 160; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 4;
            const size = 1 + Math.random() * 4;
            const sparkleColors = [0x00FFFF, 0xFFFFFF, 0xFFD700, 0xFF69B4];
            const color = sparkleColors[Math.floor(Math.random() * sparkleColors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX;
            particle.y = explosionCenterY;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = -Math.random() * 5;
            particle.life = 1.0;
            particle.maxLife = 40 + Math.random() * 40;
            particle.type = 'sparkle';
            particle.twinkle = Math.random() * Math.PI * 2;
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
          // Create yellow spark cloud (800)
          for (let i = 0; i < 800; i++) {
            const particle = new PIXI.Graphics();
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.25 + Math.random() * 1.5;
            const size = 1 + Math.random() * 3;
            const yellowColors = [0xFFFF00, 0xFFD700, 0xFFA500, 0xFFFF99, 0xFFE135];
            const color = yellowColors[Math.floor(Math.random() * yellowColors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, size);
            particle.endFill();
            particle.x = explosionCenterX + (Math.random() - 0.5) * 20;
            particle.y = explosionCenterY + (Math.random() - 0.5) * 20;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed - 1.5;
            particle.life = 1.0;
            particle.maxLife = 240 + Math.random() * 160;
            particle.type = 'yellowCloud';
            particle.flickerPhase = Math.random() * Math.PI * 2;
            particle.expansion = 0;
            particle.gravity = 0.02 + Math.random() * 0.04;
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
        }

        // Animation loop for exploding pieces
        // Create a red/yellow/orange burst explosion with trails (for enemy rocket destruction)
        function createRedBurstExplosion(x, y) {
          const burstCount = 4 * (25 + Math.floor(Math.random() * 11)); // 100-140 particles
          for (let i = 0; i < burstCount; i++) {
            const particle = new PIXI.Graphics();
            // Red/yellow/orange colors
            const colors = [0xFF2222, 0xFF6600, 0xFFAA00, 0xFFD700, 0xFF8800];
            const color = colors[Math.floor(Math.random() * colors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, 1 + Math.random() * 1.2); // Smaller size
            particle.endFill();
            particle.x = x;
            particle.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.7 + Math.random() * 2.1; // Slightly slower
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;
            particle.type = 'redBurst';
            particle.trail = [];
            particle.maxTrailLength = 12 + Math.floor(Math.random() * 8);
            particle.life = 1.0;
            particle.maxLife = 40 + Math.random() * 40; // 40-80 frames (shorter lifetime)
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
          // Also spawn a small bright white sparkle explosion at the same location
          createWhiteSparkleExplosion(x, y);
        }

        // Create a small bright white sparkle explosion (100 particles, slow outward, like player rocket sparkle)
        function createWhiteSparkleExplosion(x, y) {
          const count = 320;
          for (let i = 0; i < count; i++) {
            const particle = new PIXI.Graphics();
            // White color for sparkle
            particle.beginFill(0xFFFFFF);
            particle.drawCircle(0, 0, 1.5 + Math.random() * 1.5);
            particle.endFill();
            particle.x = x;
            particle.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.2 + Math.random() * 1.3; // Wider range, slower minimum
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;
            particle.life = 1.0;
            particle.maxLife = 40 + Math.random() * 30; // 40-70 frames
            particle.type = 'whiteSparkle';
            particle.twinkle = Math.random() * Math.PI * 2;
            explosionParticles.push(particle);
            app.stage.addChild(particle);
          }
        }
        // Create a growing spark cloud at (x, y) with given final radius, particle count, and duration (frames)
        function createGrowingSparkCloud(centerX, centerY, finalRadius, particleCount, durationFrames) {
          // Track this explosion's state
          const explosion = {
            centerX,
            centerY,
            finalRadius,
            durationFrames,
            frame: 0,
            particles: [],
            currentRadius: 0
          };
          for (let i = 0; i < particleCount; i++) {
            const particle = new PIXI.Graphics();
            // Start at center
            particle.x = centerX;
            particle.y = centerY;
            // Store explosion center for animation
            particle.growCenterX = centerX;
            particle.growCenterY = centerY;
            // Angle and final distance
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * finalRadius;
            // Color: use yellow spark colors
            const yellowColors = [0xFFFF00, 0xFFD700, 0xFFA500, 0xFFFF99, 0xFFE135];
            const color = yellowColors[Math.floor(Math.random() * yellowColors.length)];
            particle.beginFill(color);
            particle.drawCircle(0, 0, 0.8 + Math.random() * 1.2); // Smaller size
            particle.endFill();
            // Animate outward over durationFrames
            particle.growAngle = angle;
            particle.growDistance = distance;
            particle.growFrame = 0;
            particle.growDuration = durationFrames;
            particle.type = 'growingSpark';
            particle.alpha = 1.0;
            // Flicker like sparkle
            particle.twinkle = Math.random() * Math.PI * 2;
            explosionParticles.push(particle);
            explosion.particles.push(particle);
            app.stage.addChild(particle);
          }
          activePlayerExplosions.push(explosion);
        }

        app.ticker.add(() => {
          // Update rockets
          for (let i = rockets.length - 1; i >= 0; i--) {
            const rocket = rockets[i];
            // Move rocket
            rocket.x += rocket.vx;
            rocket.y += rocket.vy;
            // Create trail particle at current position
            const trailParticle = new PIXI.Graphics();
            if (rocket.isPlayerRocket) {
              trailParticle.beginFill(0x00ff44); // Green for player rocket trail
            } else {
              trailParticle.beginFill(0xFF2222); // Red for enemy rocket trail
            }
            trailParticle.drawCircle(0, 0, 3);
            trailParticle.endFill();
            trailParticle.x = rocket.x;
            trailParticle.y = rocket.y;
            trailParticle.alpha = 1.0;
            trailParticle.age = 0;
            rocket.trail.push(trailParticle);
            app.stage.addChild(trailParticle);
            // Update trail particles
            for (let j = rocket.trail.length - 1; j >= 0; j--) {
              const trail = rocket.trail[j];
              trail.age++;
              const ageRatio = trail.age / rocket.maxTrailLength;
              const size = 3 - (ageRatio * 2);
              trail.scale.set(size / 3);
              trail.alpha = 1.0 - (ageRatio * 0.95);
              if (trail.age >= rocket.maxTrailLength) {
                app.stage.removeChild(trail);
                rocket.trail.splice(j, 1);
              }
            }
            // Check if rocket hit its target building (for targeted rockets)
            if (rocket.targetBuildingIdx !== undefined) {
              // Building bounding box
              const bIdx = rocket.targetBuildingIdx;
              const bx = buildingCenters[bIdx];
              const by = bottomY - buildingHeight;
              if (
                rocket.x >= bx &&
                rocket.x <= bx + buildingWidth &&
                rocket.y >= by &&
                rocket.y <= by + buildingHeight
              ) {
                explodeBuildingAt(bIdx);
                app.stage.removeChild(rocket);
                rocket.trail.forEach(trail => app.stage.removeChild(trail));
                rockets.splice(i, 1);
                continue;
              }
            } else if (rocket.isPlayerRocket) {
              // Player rocket: check if reached mouse target (within 8px)
              const dx = rocket.x - rocket.targetX;
              const dy = rocket.y - rocket.targetY;
              if (Math.sqrt(dx * dx + dy * dy) < 8) {
                // Create a large growing spark cloud at mouse target (200 particles, smaller, flicker)
                createGrowingSparkCloud(rocket.targetX, rocket.targetY, 50, 200, 120); // 2 seconds at 60fps = 120 frames
                app.stage.removeChild(rocket);
                rocket.trail.forEach(trail => app.stage.removeChild(trail));
                rockets.splice(i, 1);
                continue;
              }
            } else {
              // Old rockets: check if hit any building area
              if (rocket.y >= bottomY - buildingHeight) {
                //explodeAtPosition(centerX, bottomY);
                app.stage.removeChild(rocket);
                rocket.trail.forEach(trail => app.stage.removeChild(trail));
                rockets.splice(i, 1);
                continue;
              }
            }
            // Remove rocket if it goes off screen
            if (rocket.y > app.screen.height + 50) {
              app.stage.removeChild(rocket);
              rocket.trail.forEach(trail => app.stage.removeChild(trail));
              rockets.splice(i, 1);
            }
          }
          
          // Update building pieces
          buildingPieces.forEach((piece) => {
            if (piece.exploding && !piece.landed) {
              // Apply gravity to vertical speed
              piece.vy += 0.08; // Gravity constant
              
              // Apply rotation
              piece.rotation += piece.rotationSpeed;
              
              // Calculate next position
              const nextX = piece.x + piece.vx;
              const nextY = piece.y + piece.vy;
              
              // Check for first bounce at ground level
              if (nextY + pieceHeight >= app.screen.height && piece.vy > 0 && !piece.bounced) {
                // First bounce only - then let them fall off screen
                piece.x = nextX; // Update horizontal position
                piece.y = app.screen.height - pieceHeight; // Snap to ground for bounce
                piece.vy = -piece.vy * 0.4; // Reverse and reduce vertical velocity (40% of impact speed)
                piece.vx = piece.vx * 0.7; // Reduce horizontal velocity due to friction
                piece.rotationSpeed *= 0.6; // Reduce rotation speed
                piece.bounced = true; // Mark as having bounced
              } else {
                // Normal position update - let pieces fall off screen after bounce
                piece.x = nextX;
                piece.y = nextY;
                
                // Mark as landed (for cleanup) if piece is far off screen
                if (piece.y > app.screen.height + 200) {
                  piece.landed = true; // Will be cleaned up below
                }
              }
            }
          });
          
          // Clean up pieces that have fallen off screen
          for (let i = buildingPieces.length - 1; i >= 0; i--) {
            const piece = buildingPieces[i];
            if (piece.landed) {
              app.stage.removeChild(piece);
              buildingPieces.splice(i, 1);
            }
          }
          
          // Update explosion particles and track growing player explosions
          for (let i = explosionParticles.length - 1; i >= 0; i--) {
            const particle = explosionParticles[i];
            if (particle.type === 'growingSpark') {
              // Animate outward from center to final radius over duration
              particle.growFrame++;
              const t = Math.min(1, particle.growFrame / particle.growDuration);
              // Ease out for more natural look
              const easeT = 1 - Math.pow(1 - t, 2);
              const r = easeT * particle.growDistance;
              particle.x = particle.growCenterX + Math.cos(particle.growAngle) * r;
              particle.y = particle.growCenterY + Math.sin(particle.growAngle) * r;
              // Flicker like sparkle
              particle.twinkle += 0.3;
              const flicker = 0.5 + 0.5 * Math.sin(particle.twinkle);
              particle.alpha = (1.0 - t * 0.7) * flicker;
              // Remove after duration
              if (particle.growFrame >= particle.growDuration) {
                app.stage.removeChild(particle);
                explosionParticles.splice(i, 1);
                // Remove from activePlayerExplosions if this was the last particle
                for (let e = activePlayerExplosions.length - 1; e >= 0; e--) {
                  const exp = activePlayerExplosions[e];
                  if (exp.particles.includes(particle)) {
                    // Remove this particle from the explosion's list
                    exp.particles = exp.particles.filter(p => p !== particle);
                    // If no particles left, remove the explosion
                    if (exp.particles.length === 0) {
                      activePlayerExplosions.splice(e, 1);
                    }
                    break;
                  }
                }
                continue;
              }
              continue;
            }
            if (particle.type === 'redBurst') {
              // Move
              particle.x += particle.vx;
              particle.y += particle.vy;
              // Fade out
              particle.life -= 1 / particle.maxLife;
              particle.alpha = particle.life;
              // Add trail particle
              const trailParticle = new PIXI.Graphics();
              trailParticle.beginFill(0xFF6600);
              trailParticle.drawCircle(0, 0, 1.2);
              trailParticle.endFill();
              trailParticle.x = particle.x;
              trailParticle.y = particle.y;
              trailParticle.alpha = 0.7;
              trailParticle.age = 0;
              particle.trail.push(trailParticle);
              app.stage.addChild(trailParticle);
              // Update and clean up trail
              for (let t = particle.trail.length - 1; t >= 0; t--) {
                const tr = particle.trail[t];
                tr.age++;
                tr.alpha = 0.7 * (1 - tr.age / particle.maxTrailLength);
                tr.scale.set(1 - tr.age / particle.maxTrailLength);
                if (tr.age >= particle.maxTrailLength) {
                  app.stage.removeChild(tr);
                  particle.trail.splice(t, 1);
                }
              }
              // Remove main particle if dead
              if (particle.life <= 0 || particle.alpha <= 0) {
                // Remove all trail particles
                particle.trail.forEach(tr => app.stage.removeChild(tr));
                app.stage.removeChild(particle);
                explosionParticles.splice(i, 1);
                continue;
              }
              continue;
            }
            // Animate white sparkle explosion
            if (particle.type === 'whiteSparkle') {
              particle.x += particle.vx;
              particle.y += particle.vy;
              particle.life -= 1 / particle.maxLife;
              particle.twinkle += 0.3;
              const flicker = 0.7 + 0.3 * Math.sin(particle.twinkle * 2);
              particle.alpha = particle.life * flicker;
              particle.vx *= 0.97;
              particle.vy *= 0.97;
              if (particle.life <= 0 || particle.alpha <= 0) {
                app.stage.removeChild(particle);
                explosionParticles.splice(i, 1);
                continue;
              }
              continue;
            }
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.life -= 1 / particle.maxLife;
            if (particle.type === 'fire') {
              particle.vy += 0.05;
              particle.alpha = particle.life;
              particle.scale.set(particle.life);
              particle.vx *= 0.98;
              particle.vy *= 0.98;
            } else if (particle.type === 'sparkle') {
              particle.vy += 0.08;
              particle.twinkle += 0.3;
              particle.alpha = particle.life * (0.5 + 0.5 * Math.sin(particle.twinkle));
              particle.vx *= 0.95;
            } else if (particle.type === 'yellowCloud') {
              particle.expansion += 0.02;
              particle.vx *= 1.01;
              particle.vy += particle.gravity;
              particle.vx *= 0.995;
              particle.vy *= 0.998;
              particle.flickerPhase += 0.4;
              const flicker = 0.6 + 0.4 * Math.sin(particle.flickerPhase);
              particle.alpha = particle.life * flicker;
              const scaleVariation = 0.8 + 0.2 * Math.sin(particle.flickerPhase * 0.7);
              particle.scale.set(particle.life * scaleVariation);
            }
            if (particle.life <= 0 || particle.alpha <= 0) {
              app.stage.removeChild(particle);
              explosionParticles.splice(i, 1);
            }
          }

          // Update currentRadius for each active player explosion
          for (let e = activePlayerExplosions.length - 1; e >= 0; e--) {
            const exp = activePlayerExplosions[e];
            exp.frame++;
            const t = Math.min(1, exp.frame / exp.durationFrames);
            const easeT = 1 - Math.pow(1 - t, 2);
            exp.currentRadius = easeT * exp.finalRadius;
          }

          // Destroy enemy rockets that enter any active player explosion radius
          for (let i = rockets.length - 1; i >= 0; i--) {
            const rocket = rockets[i];
            if (rocket.isPlayerRocket) continue;
            for (let e = 0; e < activePlayerExplosions.length; e++) {
              const exp = activePlayerExplosions[e];
              const dx = rocket.x - exp.centerX;
              const dy = rocket.y - exp.centerY;
              if (Math.sqrt(dx * dx + dy * dy) < exp.currentRadius) {
                destroyEnemyRocketByPlayer(rocket);
                break;
              }
            }
          }
        });


        console.log('PixiJS Application initialized');
        console.log('Canvas size:', app.screen.width, 'x', app.screen.height);
        console.log('Renderer type:', app.renderer.type === 1 ? 'WebGL' : 'Canvas');
      });
    </script>
  </body>
</html>
